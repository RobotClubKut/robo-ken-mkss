C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_PS2
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\UART_PS2.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\UART_PS2.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DEBUG
                    -) WL(2) PR(.\DP8051\DP8051_Keil_951\Debug/UART_PS2.lst) CD OT(2,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\UART_PS2.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART_PS2.c
   3          * Version 2.50
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART_PS2.h"
  18          #if (UART_PS2_INTERNAL_CLOCK_USED)
  19              #include "UART_PS2_IntClock.h"
  20          #endif /* End UART_PS2_INTERNAL_CLOCK_USED */
  21          
  22          
  23          /***************************************
  24          * Global data allocation
  25          ***************************************/
  26          
  27          uint8 UART_PS2_initVar = 0u;
  28          
  29          #if (UART_PS2_TX_INTERRUPT_ENABLED && UART_PS2_TX_ENABLED)
                  volatile uint8 UART_PS2_txBuffer[UART_PS2_TX_BUFFER_SIZE];
                  volatile uint8 UART_PS2_txBufferRead = 0u;
                  uint8 UART_PS2_txBufferWrite = 0u;
              #endif /* (UART_PS2_TX_INTERRUPT_ENABLED && UART_PS2_TX_ENABLED) */
  34          
  35          #if (UART_PS2_RX_INTERRUPT_ENABLED && (UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED))
                  uint8 UART_PS2_errorStatus = 0u;
                  volatile uint8 UART_PS2_rxBuffer[UART_PS2_RX_BUFFER_SIZE];
                  volatile uint8 UART_PS2_rxBufferRead  = 0u;
                  volatile uint8 UART_PS2_rxBufferWrite = 0u;
                  volatile uint8 UART_PS2_rxBufferLoopDetect = 0u;
                  volatile uint8 UART_PS2_rxBufferOverflow   = 0u;
                  #if (UART_PS2_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_PS2_rxAddressMode = UART_PS2_RX_ADDRESS_MODE;
                      volatile uint8 UART_PS2_rxAddressDetected = 0u;
                  #endif /* (UART_PS2_RXHW_ADDRESS_ENABLED) */
              #endif /* (UART_PS2_RX_INTERRUPT_ENABLED && (UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED)) */
  47          
  48          
  49          /*******************************************************************************
  50          * Function Name: UART_PS2_Start
  51          ********************************************************************************
  52          *
  53          * Summary:
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 2   

  54          *  This is the preferred method to begin component operation.
  55          *  UART_PS2_Start() sets the initVar variable, calls the
  56          *  UART_PS2_Init() function, and then calls the
  57          *  UART_PS2_Enable() function.
  58          *
  59          * Parameters:
  60          *  None.
  61          *
  62          * Return:
  63          *  None.
  64          *
  65          * Global variables:
  66          *  The UART_PS2_intiVar variable is used to indicate initial
  67          *  configuration of this component. The variable is initialized to zero (0u)
  68          *  and set to one (1u) the first time UART_PS2_Start() is called. This
  69          *  allows for component initialization without re-initialization in all
  70          *  subsequent calls to the UART_PS2_Start() routine.
  71          *
  72          * Reentrant:
  73          *  No.
  74          *
  75          *******************************************************************************/
  76          void UART_PS2_Start(void) 
  77          {
  78   1          /* If not initialized then initialize all required hardware and software */
  79   1          if(UART_PS2_initVar == 0u)
  80   1          {
  81   2              UART_PS2_Init();
  82   2              UART_PS2_initVar = 1u;
  83   2          }
  84   1      
  85   1          UART_PS2_Enable();
  86   1      }
  87          
  88          
  89          /*******************************************************************************
  90          * Function Name: UART_PS2_Init
  91          ********************************************************************************
  92          *
  93          * Summary:
  94          *  Initializes or restores the component according to the customizer Configure
  95          *  dialog settings. It is not necessary to call UART_PS2_Init() because
  96          *  the UART_PS2_Start() API calls this function and is the preferred
  97          *  method to begin component operation.
  98          *
  99          * Parameters:
 100          *  None.
 101          *
 102          * Return:
 103          *  None.
 104          *
 105          *******************************************************************************/
 106          void UART_PS2_Init(void) 
 107          {
 108   1          #if(UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED)
 109   1      
 110   1              #if (UART_PS2_RX_INTERRUPT_ENABLED)
                          /* Set RX interrupt vector and priority */
                          (void) CyIntSetVector(UART_PS2_RX_VECT_NUM, &UART_PS2_RXISR);
                          CyIntSetPriority(UART_PS2_RX_VECT_NUM, UART_PS2_RX_PRIOR_NUM);
                          UART_PS2_errorStatus = 0u;
                      #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 3   

 116   1      
 117   1              #if (UART_PS2_RXHW_ADDRESS_ENABLED)
                          UART_PS2_SetRxAddressMode(UART_PS2_RX_ADDRESS_MODE);
                          UART_PS2_SetRxAddress1(UART_PS2_RX_HW_ADDRESS1);
                          UART_PS2_SetRxAddress2(UART_PS2_RX_HW_ADDRESS2);
                      #endif /* End UART_PS2_RXHW_ADDRESS_ENABLED */
 122   1      
 123   1              /* Init Count7 period */
 124   1              UART_PS2_RXBITCTR_PERIOD_REG = UART_PS2_RXBITCTR_INIT;
 125   1              /* Configure the Initial RX interrupt mask */
 126   1              UART_PS2_RXSTATUS_MASK_REG  = UART_PS2_INIT_RX_INTERRUPTS_MASK;
 127   1          #endif /* End UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED*/
 128   1      
 129   1          #if(UART_PS2_TX_ENABLED)
                      #if (UART_PS2_TX_INTERRUPT_ENABLED)
                          /* Set TX interrupt vector and priority */
                          (void) CyIntSetVector(UART_PS2_TX_VECT_NUM, &UART_PS2_TXISR);
                          CyIntSetPriority(UART_PS2_TX_VECT_NUM, UART_PS2_TX_PRIOR_NUM);
                      #endif /* (UART_PS2_TX_INTERRUPT_ENABLED) */
              
                      /* Write Counter Value for TX Bit Clk Generator*/
                      #if (UART_PS2_TXCLKGEN_DP)
                          UART_PS2_TXBITCLKGEN_CTR_REG = UART_PS2_BIT_CENTER;
                          UART_PS2_TXBITCLKTX_COMPLETE_REG = ((UART_PS2_NUMBER_OF_DATA_BITS +
                                      UART_PS2_NUMBER_OF_START_BIT) * UART_PS2_OVER_SAMPLE_COUNT) - 1u;
                      #else
                          UART_PS2_TXBITCTR_PERIOD_REG = ((UART_PS2_NUMBER_OF_DATA_BITS +
                                      UART_PS2_NUMBER_OF_START_BIT) * UART_PS2_OVER_SAMPLE_8) - 1u;
                      #endif /* End UART_PS2_TXCLKGEN_DP */
              
                      /* Configure the Initial TX interrupt mask */
                      #if (UART_PS2_TX_INTERRUPT_ENABLED)
                          UART_PS2_TXSTATUS_MASK_REG = UART_PS2_TX_STS_FIFO_EMPTY;
                      #else
                          UART_PS2_TXSTATUS_MASK_REG = UART_PS2_INIT_TX_INTERRUPTS_MASK;
                      #endif /*End UART_PS2_TX_INTERRUPT_ENABLED*/
              
                  #endif /* End UART_PS2_TX_ENABLED */
 154   1      
 155   1          #if(UART_PS2_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_PS2_WriteControlRegister( \
                          (UART_PS2_ReadControlRegister() & (uint8)~UART_PS2_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(UART_PS2_PARITY_TYPE << UART_PS2_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_PS2_PARITY_TYPE_SW */
 160   1      }
 161          
 162          
 163          /*******************************************************************************
 164          * Function Name: UART_PS2_Enable
 165          ********************************************************************************
 166          *
 167          * Summary:
 168          *  Activates the hardware and begins component operation. It is not necessary
 169          *  to call UART_PS2_Enable() because the UART_PS2_Start() API
 170          *  calls this function, which is the preferred method to begin component
 171          *  operation.
 172          
 173          * Parameters:
 174          *  None.
 175          *
 176          * Return:
 177          *  None.
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 4   

 178          *
 179          * Global Variables:
 180          *  UART_PS2_rxAddressDetected - set to initial state (0).
 181          *
 182          *******************************************************************************/
 183          void UART_PS2_Enable(void) 
 184          {
 185   1          uint8 enableInterrupts;
 186   1          enableInterrupts = CyEnterCriticalSection();
 187   1      
 188   1          #if (UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED)
 189   1              /* RX Counter (Count7) Enable */
 190   1              UART_PS2_RXBITCTR_CONTROL_REG |= UART_PS2_CNTR_ENABLE;
 191   1      
 192   1              /* Enable the RX Interrupt */
 193   1              UART_PS2_RXSTATUS_ACTL_REG  |= UART_PS2_INT_ENABLE;
 194   1      
 195   1              #if (UART_PS2_RX_INTERRUPT_ENABLED)
                          UART_PS2_EnableRxInt();
              
                          #if (UART_PS2_RXHW_ADDRESS_ENABLED)
                              UART_PS2_rxAddressDetected = 0u;
                          #endif /* (UART_PS2_RXHW_ADDRESS_ENABLED) */
                      #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
 202   1          #endif /* (UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED) */
 203   1      
 204   1          #if(UART_PS2_TX_ENABLED)
                      /* TX Counter (DP/Count7) Enable */
                      #if(!UART_PS2_TXCLKGEN_DP)
                          UART_PS2_TXBITCTR_CONTROL_REG |= UART_PS2_CNTR_ENABLE;
                      #endif /* End UART_PS2_TXCLKGEN_DP */
              
                      /* Enable the TX Interrupt */
                      UART_PS2_TXSTATUS_ACTL_REG |= UART_PS2_INT_ENABLE;
                      #if (UART_PS2_TX_INTERRUPT_ENABLED)
                          UART_PS2_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
                          UART_PS2_EnableTxInt();
                      #endif /* (UART_PS2_TX_INTERRUPT_ENABLED) */
                   #endif /* (UART_PS2_TX_INTERRUPT_ENABLED) */
 217   1      
 218   1          #if (UART_PS2_INTERNAL_CLOCK_USED)
 219   1              UART_PS2_IntClock_Start();  /* Enable the clock */
 220   1          #endif /* (UART_PS2_INTERNAL_CLOCK_USED) */
 221   1      
 222   1          CyExitCriticalSection(enableInterrupts);
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: UART_PS2_Stop
 228          ********************************************************************************
 229          *
 230          * Summary:
 231          *  Disables the UART operation.
 232          *
 233          * Parameters:
 234          *  None.
 235          *
 236          * Return:
 237          *  None.
 238          *
 239          *******************************************************************************/
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 5   

 240          void UART_PS2_Stop(void) 
 241          {
 242   1          uint8 enableInterrupts;
 243   1          enableInterrupts = CyEnterCriticalSection();
 244   1      
 245   1          /* Write Bit Counter Disable */
 246   1          #if (UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED)
 247   1              UART_PS2_RXBITCTR_CONTROL_REG &= (uint8) ~UART_PS2_CNTR_ENABLE;
 248   1          #endif /* (UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED) */
 249   1      
 250   1          #if (UART_PS2_TX_ENABLED)
                      #if(!UART_PS2_TXCLKGEN_DP)
                          UART_PS2_TXBITCTR_CONTROL_REG &= (uint8) ~UART_PS2_CNTR_ENABLE;
                      #endif /* (!UART_PS2_TXCLKGEN_DP) */
                  #endif /* (UART_PS2_TX_ENABLED) */
 255   1      
 256   1          #if (UART_PS2_INTERNAL_CLOCK_USED)
 257   1              UART_PS2_IntClock_Stop();   /* Disable the clock */
 258   1          #endif /* (UART_PS2_INTERNAL_CLOCK_USED) */
 259   1      
 260   1          /* Disable internal interrupt component */
 261   1          #if (UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED)
 262   1              UART_PS2_RXSTATUS_ACTL_REG  &= (uint8) ~UART_PS2_INT_ENABLE;
 263   1      
 264   1              #if (UART_PS2_RX_INTERRUPT_ENABLED)
                          UART_PS2_DisableRxInt();
                      #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
 267   1          #endif /* (UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED) */
 268   1      
 269   1          #if (UART_PS2_TX_ENABLED)
                      UART_PS2_TXSTATUS_ACTL_REG &= (uint8) ~UART_PS2_INT_ENABLE;
              
                      #if (UART_PS2_TX_INTERRUPT_ENABLED)
                          UART_PS2_DisableTxInt();
                      #endif /* (UART_PS2_TX_INTERRUPT_ENABLED) */
                  #endif /* (UART_PS2_TX_ENABLED) */
 276   1      
 277   1          CyExitCriticalSection(enableInterrupts);
 278   1      }
 279          
 280          
 281          /*******************************************************************************
 282          * Function Name: UART_PS2_ReadControlRegister
 283          ********************************************************************************
 284          *
 285          * Summary:
 286          *  Returns the current value of the control register.
 287          *
 288          * Parameters:
 289          *  None.
 290          *
 291          * Return:
 292          *  Contents of the control register.
 293          *
 294          *******************************************************************************/
 295          uint8 UART_PS2_ReadControlRegister(void) 
 296          {
 297   1          #if (UART_PS2_CONTROL_REG_REMOVED)
 298   1              return(0u);
 299   1          #else
                      return(UART_PS2_CONTROL_REG);
                  #endif /* (UART_PS2_CONTROL_REG_REMOVED) */
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 6   

 302   1      }
 303          
 304          
 305          /*******************************************************************************
 306          * Function Name: UART_PS2_WriteControlRegister
 307          ********************************************************************************
 308          *
 309          * Summary:
 310          *  Writes an 8-bit value into the control register
 311          *
 312          * Parameters:
 313          *  control:  control register value
 314          *
 315          * Return:
 316          *  None.
 317          *
 318          *******************************************************************************/
 319          void  UART_PS2_WriteControlRegister(uint8 control) 
 320          {
 321   1          #if (UART_PS2_CONTROL_REG_REMOVED)
 322   1              if(0u != control)
 323   1              {
 324   2                  /* Suppress compiler warning */
 325   2              }
 326   1          #else
                     UART_PS2_CONTROL_REG = control;
                  #endif /* (UART_PS2_CONTROL_REG_REMOVED) */
 329   1      }
 330          
 331          
 332          #if(UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED)
 333              /*******************************************************************************
 334              * Function Name: UART_PS2_SetRxInterruptMode
 335              ********************************************************************************
 336              *
 337              * Summary:
 338              *  Configures the RX interrupt sources enabled.
 339              *
 340              * Parameters:
 341              *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342              *  bit-field arrangement of the status register. This value must be a 
 343              *  combination of status register bit-masks shown below:
 344              *      UART_PS2_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345              *      UART_PS2_RX_STS_PAR_ERROR        Interrupt on parity error.
 346              *      UART_PS2_RX_STS_STOP_ERROR       Interrupt on stop error.
 347              *      UART_PS2_RX_STS_BREAK            Interrupt on break.
 348              *      UART_PS2_RX_STS_OVERRUN          Interrupt on overrun error.
 349              *      UART_PS2_RX_STS_ADDR_MATCH       Interrupt on address match.
 350              *      UART_PS2_RX_STS_MRKSPC           Interrupt on address detect.
 351              *
 352              * Return:
 353              *  None.
 354              *
 355              * Theory:
 356              *  Enables the output of specific status bits to the interrupt controller
 357              *
 358              *******************************************************************************/
 359              void UART_PS2_SetRxInterruptMode(uint8 intSrc) 
 360              {
 361   1              UART_PS2_RXSTATUS_MASK_REG  = intSrc;
 362   1          }
 363          
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 7   

 364          
 365              /*******************************************************************************
 366              * Function Name: UART_PS2_ReadRxData
 367              ********************************************************************************
 368              *
 369              * Summary:
 370              *  Returns the next byte of received data. This function returns data without
 371              *  checking the status. You must check the status separately.
 372              *
 373              * Parameters:
 374              *  None.
 375              *
 376              * Return:
 377              *  Received data from RX register
 378              *
 379              * Global Variables:
 380              *  UART_PS2_rxBuffer - RAM buffer pointer for save received data.
 381              *  UART_PS2_rxBufferWrite - cyclic index for write to rxBuffer,
 382              *     checked to identify new data.
 383              *  UART_PS2_rxBufferRead - cyclic index for read from rxBuffer,
 384              *     incremented after each byte has been read from buffer.
 385              *  UART_PS2_rxBufferLoopDetect - cleared if loop condition was detected
 386              *     in RX ISR.
 387              *
 388              * Reentrant:
 389              *  No.
 390              *
 391              *******************************************************************************/
 392              uint8 UART_PS2_ReadRxData(void) 
 393              {
 394   1              uint8 rxData;
 395   1      
 396   1          #if (UART_PS2_RX_INTERRUPT_ENABLED)
              
                      uint8 locRxBufferRead;
                      uint8 locRxBufferWrite;
              
                      /* Protect variables that could change on interrupt */
                      UART_PS2_DisableRxInt();
              
                      locRxBufferRead  = UART_PS2_rxBufferRead;
                      locRxBufferWrite = UART_PS2_rxBufferWrite;
              
                      if( (UART_PS2_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
                      {
                          rxData = UART_PS2_rxBuffer[locRxBufferRead];
                          locRxBufferRead++;
              
                          if(locRxBufferRead >= UART_PS2_RX_BUFFER_SIZE)
                          {
                              locRxBufferRead = 0u;
                          }
                          /* Update the real pointer */
                          UART_PS2_rxBufferRead = locRxBufferRead;
              
                          if(UART_PS2_rxBufferLoopDetect != 0u)
                          {
                              UART_PS2_rxBufferLoopDetect = 0u;
                              #if ((UART_PS2_RX_INTERRUPT_ENABLED) && (UART_PS2_FLOW_CONTROL != 0u))
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_PS2_HD_ENABLED )
                                      if((UART_PS2_CONTROL_REG & UART_PS2_CTRL_HD_SEND) == 0u)
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 8   

                                      {   /* In Half duplex mode return RX mask only in RX
                                          *  configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_PS2_RXSTATUS_MASK_REG  |= UART_PS2_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_PS2_RXSTATUS_MASK_REG  |= UART_PS2_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_PS2_HD_ENABLED */
                              #endif /* ((UART_PS2_RX_INTERRUPT_ENABLED) && (UART_PS2_FLOW_CONTROL != 0u)) */
                          }
                      }
                      else
                      {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
                          rxData = UART_PS2_RXDATA_REG;
                      }
              
                      UART_PS2_EnableRxInt();
              
                  #else
 446   1      
 447   1              /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 448   1              rxData = UART_PS2_RXDATA_REG;
 449   1      
 450   1          #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
 451   1      
 452   1              return(rxData);
 453   1          }
 454          
 455          
 456              /*******************************************************************************
 457              * Function Name: UART_PS2_ReadRxStatus
 458              ********************************************************************************
 459              *
 460              * Summary:
 461              *  Returns the current state of the receiver status register and the software
 462              *  buffer overflow status.
 463              *
 464              * Parameters:
 465              *  None.
 466              *
 467              * Return:
 468              *  Current state of the status register.
 469              *
 470              * Side Effect:
 471              *  All status register bits are clear-on-read except
 472              *  UART_PS2_RX_STS_FIFO_NOTEMPTY.
 473              *  UART_PS2_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474              *  register read.
 475              *
 476              * Global Variables:
 477              *  UART_PS2_rxBufferOverflow - used to indicate overload condition.
 478              *   It set to one in RX interrupt when there isn't free space in
 479              *   UART_PS2_rxBufferRead to write new data. This condition returned
 480              *   and cleared to zero by this API as an
 481              *   UART_PS2_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482              *   bits.
 483              *
 484              *******************************************************************************/
 485              uint8 UART_PS2_ReadRxStatus(void) 
 486              {
 487   1              uint8 status;
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 9   

 488   1      
 489   1              status = UART_PS2_RXSTATUS_REG & UART_PS2_RX_HW_MASK;
 490   1      
 491   1          #if (UART_PS2_RX_INTERRUPT_ENABLED)
                      if(UART_PS2_rxBufferOverflow != 0u)
                      {
                          status |= UART_PS2_RX_STS_SOFT_BUFF_OVER;
                          UART_PS2_rxBufferOverflow = 0u;
                      }
                  #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
 498   1      
 499   1              return(status);
 500   1          }
 501          
 502          
 503              /*******************************************************************************
 504              * Function Name: UART_PS2_GetChar
 505              ********************************************************************************
 506              *
 507              * Summary:
 508              *  Returns the last received byte of data. UART_PS2_GetChar() is
 509              *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510              *  for valid characters and 0 indicates an error occurred or no data is present.
 511              *
 512              * Parameters:
 513              *  None.
 514              *
 515              * Return:
 516              *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517              *  A returned zero signifies an error condition or no data available.
 518              *
 519              * Global Variables:
 520              *  UART_PS2_rxBuffer - RAM buffer pointer for save received data.
 521              *  UART_PS2_rxBufferWrite - cyclic index for write to rxBuffer,
 522              *     checked to identify new data.
 523              *  UART_PS2_rxBufferRead - cyclic index for read from rxBuffer,
 524              *     incremented after each byte has been read from buffer.
 525              *  UART_PS2_rxBufferLoopDetect - cleared if loop condition was detected
 526              *     in RX ISR.
 527              *
 528              * Reentrant:
 529              *  No.
 530              *
 531              *******************************************************************************/
 532              uint8 UART_PS2_GetChar(void) 
 533              {
 534   1              uint8 rxData = 0u;
 535   1              uint8 rxStatus;
 536   1      
 537   1          #if (UART_PS2_RX_INTERRUPT_ENABLED)
                      uint8 locRxBufferRead;
                      uint8 locRxBufferWrite;
              
                      /* Protect variables that could change on interrupt */
                      UART_PS2_DisableRxInt();
              
                      locRxBufferRead  = UART_PS2_rxBufferRead;
                      locRxBufferWrite = UART_PS2_rxBufferWrite;
              
                      if( (UART_PS2_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
                      {
                          rxData = UART_PS2_rxBuffer[locRxBufferRead];
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 10  

                          locRxBufferRead++;
                          if(locRxBufferRead >= UART_PS2_RX_BUFFER_SIZE)
                          {
                              locRxBufferRead = 0u;
                          }
                          /* Update the real pointer */
                          UART_PS2_rxBufferRead = locRxBufferRead;
              
                          if(UART_PS2_rxBufferLoopDetect != 0u)
                          {
                              UART_PS2_rxBufferLoopDetect = 0u;
                              #if( (UART_PS2_RX_INTERRUPT_ENABLED) && (UART_PS2_FLOW_CONTROL != 0u) )
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_PS2_HD_ENABLED )
                                      if((UART_PS2_CONTROL_REG & UART_PS2_CTRL_HD_SEND) == 0u)
                                      {   /* In Half duplex mode return RX mask only if
                                          *  RX configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_PS2_RXSTATUS_MASK_REG |= UART_PS2_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_PS2_RXSTATUS_MASK_REG |= UART_PS2_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_PS2_HD_ENABLED */
                              #endif /* UART_PS2_RX_INTERRUPT_ENABLED and Hardware flow control*/
                          }
              
                      }
                      else
                      {   rxStatus = UART_PS2_RXSTATUS_REG;
                          if((rxStatus & UART_PS2_RX_STS_FIFO_NOTEMPTY) != 0u)
                          {   /* Read received data from FIFO */
                              rxData = UART_PS2_RXDATA_REG;
                              /*Check status on error*/
                              if((rxStatus & (UART_PS2_RX_STS_BREAK | UART_PS2_RX_STS_PAR_ERROR |
                                              UART_PS2_RX_STS_STOP_ERROR | UART_PS2_RX_STS_OVERRUN)) != 0u)
                              {
                                  rxData = 0u;
                              }
                          }
                      }
              
                      UART_PS2_EnableRxInt();
              
                  #else
 595   1      
 596   1              rxStatus =UART_PS2_RXSTATUS_REG;
 597   1              if((rxStatus & UART_PS2_RX_STS_FIFO_NOTEMPTY) != 0u)
 598   1              {
 599   2                  /* Read received data from FIFO */
 600   2                  rxData = UART_PS2_RXDATA_REG;
 601   2      
 602   2                  /*Check status on error*/
 603   2                  if((rxStatus & (UART_PS2_RX_STS_BREAK | UART_PS2_RX_STS_PAR_ERROR |
 604   2                                  UART_PS2_RX_STS_STOP_ERROR | UART_PS2_RX_STS_OVERRUN)) != 0u)
 605   2                  {
 606   3                      rxData = 0u;
 607   3                  }
 608   2              }
 609   1          #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
 610   1      
 611   1              return(rxData);
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 11  

 612   1          }
 613          
 614          
 615              /*******************************************************************************
 616              * Function Name: UART_PS2_GetByte
 617              ********************************************************************************
 618              *
 619              * Summary:
 620              *  Reads UART RX buffer immediately, returns received character and error
 621              *  condition.
 622              *
 623              * Parameters:
 624              *  None.
 625              *
 626              * Return:
 627              *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628              *  an error has occurred.
 629              *
 630              * Reentrant:
 631              *  No.
 632              *
 633              *******************************************************************************/
 634              uint16 UART_PS2_GetByte(void) 
 635              {
 636   1              
 637   1          #if (UART_PS2_RX_INTERRUPT_ENABLED)
                      uint16 locErrorStatus;
                      /* Protect variables that could change on interrupt */
                      UART_PS2_DisableRxInt();
                      locErrorStatus = (uint16)UART_PS2_errorStatus;
                      UART_PS2_errorStatus = 0u;
                      UART_PS2_EnableRxInt();
                      return ( (uint16)(locErrorStatus << 8u) | UART_PS2_ReadRxData() );
                  #else
 646   1              return ( ((uint16)UART_PS2_ReadRxStatus() << 8u) | UART_PS2_ReadRxData() );
 647   1          #endif /* UART_PS2_RX_INTERRUPT_ENABLED */
 648   1              
 649   1          }
 650          
 651          
 652              /*******************************************************************************
 653              * Function Name: UART_PS2_GetRxBufferSize
 654              ********************************************************************************
 655              *
 656              * Summary:
 657              *  Returns the number of received bytes available in the RX buffer.
 658              *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659              *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660              *  * RX software buffer is enabled: returns the number of bytes available in 
 661              *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662              *    account.
 663              *
 664              * Parameters:
 665              *  None.
 666              *
 667              * Return:
 668              *  uint8: Number of bytes in the RX buffer. 
 669              *    Return value type depends on RX Buffer Size parameter.
 670              *
 671              * Global Variables:
 672              *  UART_PS2_rxBufferWrite - used to calculate left bytes.
 673              *  UART_PS2_rxBufferRead - used to calculate left bytes.
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 12  

 674              *  UART_PS2_rxBufferLoopDetect - checked to decide left bytes amount.
 675              *
 676              * Reentrant:
 677              *  No.
 678              *
 679              * Theory:
 680              *  Allows the user to find out how full the RX Buffer is.
 681              *
 682              *******************************************************************************/
 683              uint8 UART_PS2_GetRxBufferSize(void)
 684                                                                      
 685              {
 686   1              uint8 size;
 687   1      
 688   1          #if (UART_PS2_RX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt */
                      UART_PS2_DisableRxInt();
              
                      if(UART_PS2_rxBufferRead == UART_PS2_rxBufferWrite)
                      {
                          if(UART_PS2_rxBufferLoopDetect != 0u)
                          {
                              size = UART_PS2_RX_BUFFER_SIZE;
                          }
                          else
                          {
                              size = 0u;
                          }
                      }
                      else if(UART_PS2_rxBufferRead < UART_PS2_rxBufferWrite)
                      {
                          size = (UART_PS2_rxBufferWrite - UART_PS2_rxBufferRead);
                      }
                      else
                      {
                          size = (UART_PS2_RX_BUFFER_SIZE - UART_PS2_rxBufferRead) + UART_PS2_rxBufferWrite;
                      }
              
                      UART_PS2_EnableRxInt();
              
                  #else
 716   1      
 717   1              /* We can only know if there is data in the fifo. */
 718   1              size = ((UART_PS2_RXSTATUS_REG & UART_PS2_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
 719   1      
 720   1          #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
 721   1      
 722   1              return(size);
 723   1          }
 724          
 725          
 726              /*******************************************************************************
 727              * Function Name: UART_PS2_ClearRxBuffer
 728              ********************************************************************************
 729              *
 730              * Summary:
 731              *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732              *
 733              * Parameters:
 734              *  None.
 735              *
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 13  

 736              * Return:
 737              *  None.
 738              *
 739              * Global Variables:
 740              *  UART_PS2_rxBufferWrite - cleared to zero.
 741              *  UART_PS2_rxBufferRead - cleared to zero.
 742              *  UART_PS2_rxBufferLoopDetect - cleared to zero.
 743              *  UART_PS2_rxBufferOverflow - cleared to zero.
 744              *
 745              * Reentrant:
 746              *  No.
 747              *
 748              * Theory:
 749              *  Setting the pointers to zero makes the system believe there is no data to
 750              *  read and writing will resume at address 0 overwriting any data that may
 751              *  have remained in the RAM.
 752              *
 753              * Side Effects:
 754              *  Any received data not read from the RAM or FIFO buffer will be lost.
 755              *
 756              *******************************************************************************/
 757              void UART_PS2_ClearRxBuffer(void) 
 758              {
 759   1              uint8 enableInterrupts;
 760   1      
 761   1              /* Clear the HW FIFO */
 762   1              enableInterrupts = CyEnterCriticalSection();
 763   1              UART_PS2_RXDATA_AUX_CTL_REG |= (uint8)  UART_PS2_RX_FIFO_CLR;
 764   1              UART_PS2_RXDATA_AUX_CTL_REG &= (uint8) ~UART_PS2_RX_FIFO_CLR;
 765   1              CyExitCriticalSection(enableInterrupts);
 766   1      
 767   1          #if (UART_PS2_RX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_PS2_DisableRxInt();
              
                      UART_PS2_rxBufferRead = 0u;
                      UART_PS2_rxBufferWrite = 0u;
                      UART_PS2_rxBufferLoopDetect = 0u;
                      UART_PS2_rxBufferOverflow = 0u;
              
                      UART_PS2_EnableRxInt();
              
                  #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
 780   1      
 781   1          }
 782          
 783          
 784              /*******************************************************************************
 785              * Function Name: UART_PS2_SetRxAddressMode
 786              ********************************************************************************
 787              *
 788              * Summary:
 789              *  Sets the software controlled Addressing mode used by the RX portion of the
 790              *  UART.
 791              *
 792              * Parameters:
 793              *  addressMode: Enumerated value indicating the mode of RX addressing
 794              *  UART_PS2__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795              *                                               detection
 796              *  UART_PS2__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
 797              *                                               address detection
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 14  

 798              *  UART_PS2__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799              *                                               detection
 800              *  UART_PS2__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801              *                                               address detection
 802              *  UART_PS2__B_UART__AM_NONE - No address detection
 803              *
 804              * Return:
 805              *  None.
 806              *
 807              * Global Variables:
 808              *  UART_PS2_rxAddressMode - the parameter stored in this variable for
 809              *   the farther usage in RX ISR.
 810              *  UART_PS2_rxAddressDetected - set to initial state (0).
 811              *
 812              *******************************************************************************/
 813              void UART_PS2_SetRxAddressMode(uint8 addressMode)
 814                                                                  
 815              {
 816   1              #if(UART_PS2_RXHW_ADDRESS_ENABLED)
                          #if(UART_PS2_CONTROL_REG_REMOVED)
                              if(0u != addressMode)
                              {
                                  /* Suppress compiler warning */
                              }
                          #else /* UART_PS2_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = UART_PS2_CONTROL_REG & (uint8)~UART_PS2_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << UART_PS2_CTRL_RXADDR_MODE0_SHIFT);
                              UART_PS2_CONTROL_REG = tmpCtrl;
              
                              #if(UART_PS2_RX_INTERRUPT_ENABLED && \
                                 (UART_PS2_RXBUFFERSIZE > UART_PS2_FIFO_LENGTH) )
                                  UART_PS2_rxAddressMode = addressMode;
                                  UART_PS2_rxAddressDetected = 0u;
                              #endif /* End UART_PS2_RXBUFFERSIZE > UART_PS2_FIFO_LENGTH*/
                          #endif /* End UART_PS2_CONTROL_REG_REMOVED */
                      #else /* UART_PS2_RXHW_ADDRESS_ENABLED */
 835   1                  if(0u != addressMode)
 836   1                  {
 837   2                      /* Suppress compiler warning */
 838   2                  }
 839   1              #endif /* End UART_PS2_RXHW_ADDRESS_ENABLED */
 840   1          }
 841          
 842          
 843              /*******************************************************************************
 844              * Function Name: UART_PS2_SetRxAddress1
 845              ********************************************************************************
 846              *
 847              * Summary:
 848              *  Sets the first of two hardware-detectable receiver addresses.
 849              *
 850              * Parameters:
 851              *  address: Address #1 for hardware address detection.
 852              *
 853              * Return:
 854              *  None.
 855              *
 856              *******************************************************************************/
 857              void UART_PS2_SetRxAddress1(uint8 address) 
 858              {
 859   1              UART_PS2_RXADDRESS1_REG = address;
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 15  

 860   1          }
 861          
 862          
 863              /*******************************************************************************
 864              * Function Name: UART_PS2_SetRxAddress2
 865              ********************************************************************************
 866              *
 867              * Summary:
 868              *  Sets the second of two hardware-detectable receiver addresses.
 869              *
 870              * Parameters:
 871              *  address: Address #2 for hardware address detection.
 872              *
 873              * Return:
 874              *  None.
 875              *
 876              *******************************************************************************/
 877              void UART_PS2_SetRxAddress2(uint8 address) 
 878              {
 879   1              UART_PS2_RXADDRESS2_REG = address;
 880   1          }
 881          
 882          #endif  /* UART_PS2_RX_ENABLED || UART_PS2_HD_ENABLED*/
 883          
 884          
 885          #if( (UART_PS2_TX_ENABLED) || (UART_PS2_HD_ENABLED) )
                  /*******************************************************************************
                  * Function Name: UART_PS2_SetTxInterruptMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the TX interrupt sources to be enabled, but does not enable the
                  *  interrupt.
                  *
                  * Parameters:
                  *  intSrc: Bit field containing the TX interrupt sources to enable
                  *   UART_PS2_TX_STS_COMPLETE        Interrupt on TX byte complete
                  *   UART_PS2_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
                  *   UART_PS2_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
                  *   UART_PS2_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Enables the output of specific status bits to the interrupt controller
                  *
                  *******************************************************************************/
                  void UART_PS2_SetTxInterruptMode(uint8 intSrc) 
                  {
                      UART_PS2_TXSTATUS_MASK_REG = intSrc;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_WriteTxData
                  ********************************************************************************
                  *
                  * Summary:
                  *  Places a byte of data into the transmit buffer to be sent when the bus is
                  *  available without checking the TX status register. You must check status
                  *  separately.
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 16  

                  *
                  * Parameters:
                  *  txDataByte: data byte
                  *
                  * Return:
                  * None.
                  *
                  * Global Variables:
                  *  UART_PS2_txBuffer - RAM buffer pointer for save data for transmission
                  *  UART_PS2_txBufferWrite - cyclic index for write to txBuffer,
                  *    incremented after each byte saved to buffer.
                  *  UART_PS2_txBufferRead - cyclic index for read from txBuffer,
                  *    checked to identify the condition to write to FIFO directly or to TX buffer
                  *  UART_PS2_initVar - checked to identify that the component has been
                  *    initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void UART_PS2_WriteTxData(uint8 txDataByte) 
                  {
                      /* If not Initialized then skip this function*/
                      if(UART_PS2_initVar != 0u)
                      {
                      #if (UART_PS2_TX_INTERRUPT_ENABLED)
              
                          /* Protect variables that could change on interrupt. */
                          UART_PS2_DisableTxInt();
              
                          if( (UART_PS2_txBufferRead == UART_PS2_txBufferWrite) &&
                              ((UART_PS2_TXSTATUS_REG & UART_PS2_TX_STS_FIFO_FULL) == 0u) )
                          {
                              /* Add directly to the FIFO. */
                              UART_PS2_TXDATA_REG = txDataByte;
                          }
                          else
                          {
                              if(UART_PS2_txBufferWrite >= UART_PS2_TX_BUFFER_SIZE)
                              {
                                  UART_PS2_txBufferWrite = 0u;
                              }
              
                              UART_PS2_txBuffer[UART_PS2_txBufferWrite] = txDataByte;
              
                              /* Add to the software buffer. */
                              UART_PS2_txBufferWrite++;
                          }
              
                          UART_PS2_EnableTxInt();
              
                      #else
              
                          /* Add directly to the FIFO. */
                          UART_PS2_TXDATA_REG = txDataByte;
              
                      #endif /*(UART_PS2_TX_INTERRUPT_ENABLED) */
                      }
                  }
              
              
                  /*******************************************************************************
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 17  

                  * Function Name: UART_PS2_ReadTxStatus
                  ********************************************************************************
                  *
                  * Summary:
                  *  Reads the status register for the TX portion of the UART.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Contents of the status register
                  *
                  * Theory:
                  *  This function reads the TX status register, which is cleared on read.
                  *  It is up to the user to handle all bits in this return value accordingly,
                  *  even if the bit was not enabled as an interrupt source the event happened
                  *  and must be handled accordingly.
                  *
                  *******************************************************************************/
                  uint8 UART_PS2_ReadTxStatus(void) 
                  {
                      return(UART_PS2_TXSTATUS_REG);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_PutChar
                  ********************************************************************************
                  *
                  * Summary:
                  *  Puts a byte of data into the transmit buffer to be sent when the bus is
                  *  available. This is a blocking API that waits until the TX buffer has room to
                  *  hold the data.
                  *
                  * Parameters:
                  *  txDataByte: Byte containing the data to transmit
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_PS2_txBuffer - RAM buffer pointer for save data for transmission
                  *  UART_PS2_txBufferWrite - cyclic index for write to txBuffer,
                  *     checked to identify free space in txBuffer and incremented after each byte
                  *     saved to buffer.
                  *  UART_PS2_txBufferRead - cyclic index for read from txBuffer,
                  *     checked to identify free space in txBuffer.
                  *  UART_PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Allows the user to transmit any byte of data in a single transfer
                  *
                  *******************************************************************************/
                  void UART_PS2_PutChar(uint8 txDataByte) 
                  {
                  #if (UART_PS2_TX_INTERRUPT_ENABLED)
                      /* The temporary output pointer is used since it takes two instructions
                      *  to increment with a wrap, and we can't risk doing that with the real
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 18  

                      *  pointer and getting an interrupt in between instructions.
                      */
                      uint8 locTxBufferWrite;
                      uint8 locTxBufferRead;
              
                      do
                      { /* Block if software buffer is full, so we don't overwrite. */
              
                      #if ((UART_PS2_TX_BUFFER_SIZE > UART_PS2_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Disable TX interrupt to protect variables from modification */
                          UART_PS2_DisableTxInt();
                      #endif /* (UART_PS2_TX_BUFFER_SIZE > UART_PS2_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          locTxBufferWrite = UART_PS2_txBufferWrite;
                          locTxBufferRead  = UART_PS2_txBufferRead;
              
                      #if ((UART_PS2_TX_BUFFER_SIZE > UART_PS2_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Enable interrupt to continue transmission */
                          UART_PS2_EnableTxInt();
                      #endif /* (UART_PS2_TX_BUFFER_SIZE > UART_PS2_MAX_BYTE_VALUE) && (CY_PSOC3) */
                      }
                      while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) :
                                              ((locTxBufferWrite - locTxBufferRead) ==
                                              (uint8)(UART_PS2_TX_BUFFER_SIZE - 1u)) );
              
                      if( (locTxBufferRead == locTxBufferWrite) &&
                          ((UART_PS2_TXSTATUS_REG & UART_PS2_TX_STS_FIFO_FULL) == 0u) )
                      {
                          /* Add directly to the FIFO */
                          UART_PS2_TXDATA_REG = txDataByte;
                      }
                      else
                      {
                          if(locTxBufferWrite >= UART_PS2_TX_BUFFER_SIZE)
                          {
                              locTxBufferWrite = 0u;
                          }
                          /* Add to the software buffer. */
                          UART_PS2_txBuffer[locTxBufferWrite] = txDataByte;
                          locTxBufferWrite++;
              
                          /* Finally, update the real output pointer */
                      #if ((UART_PS2_TX_BUFFER_SIZE > UART_PS2_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_PS2_DisableTxInt();
                      #endif /* (UART_PS2_TX_BUFFER_SIZE > UART_PS2_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          UART_PS2_txBufferWrite = locTxBufferWrite;
              
                      #if ((UART_PS2_TX_BUFFER_SIZE > UART_PS2_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_PS2_EnableTxInt();
                      #endif /* (UART_PS2_TX_BUFFER_SIZE > UART_PS2_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          if(0u != (UART_PS2_TXSTATUS_REG & UART_PS2_TX_STS_FIFO_EMPTY))
                          {
                              /* Trigger TX interrupt to send software buffer */
                              UART_PS2_SetPendingTxInt();
                          }
                      }
              
                  #else
              
                      while((UART_PS2_TXSTATUS_REG & UART_PS2_TX_STS_FIFO_FULL) != 0u)
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 19  

                      {
                          /* Wait for room in the FIFO */
                      }
              
                      /* Add directly to the FIFO */
                      UART_PS2_TXDATA_REG = txDataByte;
              
                  #endif /* UART_PS2_TX_INTERRUPT_ENABLED */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_PutString
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sends a NULL terminated string to the TX buffer for transmission.
                  *
                  * Parameters:
                  *  string[]: Pointer to the null terminated string array residing in RAM or ROM
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  If there is not enough memory in the TX buffer for the entire string, this
                  *  function blocks until the last character of the string is loaded into the
                  *  TX buffer.
                  *
                  *******************************************************************************/
                  void UART_PS2_PutString(const char8 string[]) 
                  {
                      uint16 bufIndex = 0u;
              
                      /* If not Initialized then skip this function */
                      if(UART_PS2_initVar != 0u)
                      {
                          /* This is a blocking function, it will not exit until all data is sent */
                          while(string[bufIndex] != (char8) 0)
                          {
                              UART_PS2_PutChar((uint8)string[bufIndex]);
                              bufIndex++;
                          }
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_PutArray
                  ********************************************************************************
                  *
                  * Summary:
                  *  Places N bytes of data from a memory array into the TX buffer for
                  *  transmission.
                  *
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 20  

                  * Parameters:
                  *  string[]: Address of the memory array residing in RAM or ROM.
                  *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
                  *             Size parameter.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  If there is not enough memory in the TX buffer for the entire string, this
                  *  function blocks until the last character of the string is loaded into the
                  *  TX buffer.
                  *
                  *******************************************************************************/
                  void UART_PS2_PutArray(const uint8 string[], uint8 byteCount)
                                                                                  
                  {
                      uint8 bufIndex = 0u;
              
                      /* If not Initialized then skip this function */
                      if(UART_PS2_initVar != 0u)
                      {
                          while(bufIndex < byteCount)
                          {
                              UART_PS2_PutChar(string[bufIndex]);
                              bufIndex++;
                          }
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_PutCRLF
                  ********************************************************************************
                  *
                  * Summary:
                  *  Writes a byte of data followed by a carriage return (0x0D) and line feed
                  *  (0x0A) to the transmit buffer.
                  *
                  * Parameters:
                  *  txDataByte: Data byte to transmit before the carriage return and line feed.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  void UART_PS2_PutCRLF(uint8 txDataByte) 
                  {
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 21  

                      /* If not Initialized then skip this function */
                      if(UART_PS2_initVar != 0u)
                      {
                          UART_PS2_PutChar(txDataByte);
                          UART_PS2_PutChar(0x0Du);
                          UART_PS2_PutChar(0x0Au);
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_GetTxBufferSize
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the number of bytes in the TX buffer which are waiting to be 
                  *  transmitted.
                  *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
                  *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
                  *  * TX software buffer is enabled: returns the number of bytes in the TX 
                  *    software buffer which are waiting to be transmitted. Bytes available in the
                  *    TX FIFO do not count.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Number of bytes used in the TX buffer. Return value type depends on the TX 
                  *  Buffer Size parameter.
                  *
                  * Global Variables:
                  *  UART_PS2_txBufferWrite - used to calculate left space.
                  *  UART_PS2_txBufferRead - used to calculate left space.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Allows the user to find out how full the TX Buffer is.
                  *
                  *******************************************************************************/
                  uint8 UART_PS2_GetTxBufferSize(void)
                                                                          
                  {
                      uint8 size;
              
                  #if (UART_PS2_TX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_PS2_DisableTxInt();
              
                      if(UART_PS2_txBufferRead == UART_PS2_txBufferWrite)
                      {
                          size = 0u;
                      }
                      else if(UART_PS2_txBufferRead < UART_PS2_txBufferWrite)
                      {
                          size = (UART_PS2_txBufferWrite - UART_PS2_txBufferRead);
                      }
                      else
                      {
                          size = (UART_PS2_TX_BUFFER_SIZE - UART_PS2_txBufferRead) +
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 22  

                                  UART_PS2_txBufferWrite;
                      }
              
                      UART_PS2_EnableTxInt();
              
                  #else
              
                      size = UART_PS2_TXSTATUS_REG;
              
                      /* Is the fifo is full. */
                      if((size & UART_PS2_TX_STS_FIFO_FULL) != 0u)
                      {
                          size = UART_PS2_FIFO_LENGTH;
                      }
                      else if((size & UART_PS2_TX_STS_FIFO_EMPTY) != 0u)
                      {
                          size = 0u;
                      }
                      else
                      {
                          /* We only know there is data in the fifo. */
                          size = 1u;
                      }
              
                  #endif /* (UART_PS2_TX_INTERRUPT_ENABLED) */
              
                  return(size);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_ClearTxBuffer
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears all data from the TX buffer and hardware TX FIFO.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_PS2_txBufferWrite - cleared to zero.
                  *  UART_PS2_txBufferRead - cleared to zero.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Setting the pointers to zero makes the system believe there is no data to
                  *  read and writing will resume at address 0 overwriting any data that may have
                  *  remained in the RAM.
                  *
                  * Side Effects:
                  *  Data waiting in the transmit buffer is not sent; a byte that is currently
                  *  transmitting finishes transmitting.
                  *
                  *******************************************************************************/
                  void UART_PS2_ClearTxBuffer(void) 
                  {
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 23  

                      uint8 enableInterrupts;
              
                      enableInterrupts = CyEnterCriticalSection();
                      /* Clear the HW FIFO */
                      UART_PS2_TXDATA_AUX_CTL_REG |= (uint8)  UART_PS2_TX_FIFO_CLR;
                      UART_PS2_TXDATA_AUX_CTL_REG &= (uint8) ~UART_PS2_TX_FIFO_CLR;
                      CyExitCriticalSection(enableInterrupts);
              
                  #if (UART_PS2_TX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_PS2_DisableTxInt();
              
                      UART_PS2_txBufferRead = 0u;
                      UART_PS2_txBufferWrite = 0u;
              
                      /* Enable Tx interrupt. */
                      UART_PS2_EnableTxInt();
              
                  #endif /* (UART_PS2_TX_INTERRUPT_ENABLED) */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_SendBreak
                  ********************************************************************************
                  *
                  * Summary:
                  *  Transmits a break signal on the bus.
                  *
                  * Parameters:
                  *  uint8 retMode:  Send Break return mode. See the following table for options.
                  *   UART_PS2_SEND_BREAK - Initialize registers for break, send the Break
                  *       signal and return immediately.
                  *   UART_PS2_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
                  *       complete, reinitialize registers to normal transmission mode then return
                  *   UART_PS2_REINIT - Reinitialize registers to normal transmission mode
                  *       then return.
                  *   UART_PS2_SEND_WAIT_REINIT - Performs both options: 
                  *      UART_PS2_SEND_BREAK and UART_PS2_WAIT_FOR_COMPLETE_REINIT.
                  *      This option is recommended for most cases.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_PS2_initVar - checked to identify that the component has been
                  *     initialized.
                  *  txPeriod - static variable, used for keeping TX period configuration.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  SendBreak function initializes registers to send 13-bit break signal. It is
                  *  important to return the registers configuration to normal for continue 8-bit
                  *  operation.
                  *  There are 3 variants for this API usage:
                  *  1) SendBreak(3) - function will send the Break signal and take care on the
                  *     configuration returning. Function will block CPU until transmission
                  *     complete.
                  *  2) User may want to use blocking time if UART configured to the low speed
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 24  

                  *     operation
                  *     Example for this case:
                  *     SendBreak(0);     - initialize Break signal transmission
                  *         Add your code here to use CPU time
                  *     SendBreak(1);     - complete Break operation
                  *  3) Same to 2) but user may want to initialize and use the interrupt to
                  *     complete break operation.
                  *     Example for this case:
                  *     Initialize TX interrupt with "TX - On TX Complete" parameter
                  *     SendBreak(0);     - initialize Break signal transmission
                  *         Add your code here to use CPU time
                  *     When interrupt appear with UART_PS2_TX_STS_COMPLETE status:
                  *     SendBreak(2);     - complete Break operation
                  *
                  * Side Effects:
                  *  The UART_PS2_SendBreak() function initializes registers to send a
                  *  break signal.
                  *  Break signal length depends on the break signal bits configuration.
                  *  The register configuration should be reinitialized before normal 8-bit
                  *  communication can continue.
                  *
                  *******************************************************************************/
                  void UART_PS2_SendBreak(uint8 retMode) 
                  {
              
                      /* If not Initialized then skip this function*/
                      if(UART_PS2_initVar != 0u)
                      {
                          /* Set the Counter to 13-bits and transmit a 00 byte */
                          /* When that is done then reset the counter value back */
                          uint8 tmpStat;
              
                      #if(UART_PS2_HD_ENABLED) /* Half Duplex mode*/
              
                          if( (retMode == UART_PS2_SEND_BREAK) ||
                              (retMode == UART_PS2_SEND_WAIT_REINIT ) )
                          {
                              /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
                              UART_PS2_WriteControlRegister(UART_PS2_ReadControlRegister() |
                                                                    UART_PS2_CTRL_HD_SEND_BREAK);
                              /* Send zeros */
                              UART_PS2_TXDATA_REG = 0u;
              
                              do /* Wait until transmit starts */
                              {
                                  tmpStat = UART_PS2_TXSTATUS_REG;
                              }
                              while((tmpStat & UART_PS2_TX_STS_FIFO_EMPTY) != 0u);
                          }
              
                          if( (retMode == UART_PS2_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_PS2_SEND_WAIT_REINIT) )
                          {
                              do /* Wait until transmit complete */
                              {
                                  tmpStat = UART_PS2_TXSTATUS_REG;
                              }
                              while(((uint8)~tmpStat & UART_PS2_TX_STS_COMPLETE) != 0u);
                          }
              
                          if( (retMode == UART_PS2_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_PS2_REINIT) ||
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 25  

                              (retMode == UART_PS2_SEND_WAIT_REINIT) )
                          {
                              UART_PS2_WriteControlRegister(UART_PS2_ReadControlRegister() &
                                                            (uint8)~UART_PS2_CTRL_HD_SEND_BREAK);
                          }
              
                      #else /* UART_PS2_HD_ENABLED Full Duplex mode */
              
                          static uint8 txPeriod;
              
                          if( (retMode == UART_PS2_SEND_BREAK) ||
                              (retMode == UART_PS2_SEND_WAIT_REINIT) )
                          {
                              /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode */
                              #if( (UART_PS2_PARITY_TYPE != UART_PS2__B_UART__NONE_REVB) || \
                                                  (UART_PS2_PARITY_TYPE_SW != 0u) )
                                  UART_PS2_WriteControlRegister(UART_PS2_ReadControlRegister() |
                                                                        UART_PS2_CTRL_HD_SEND_BREAK);
                              #endif /* End UART_PS2_PARITY_TYPE != UART_PS2__B_UART__NONE_REVB  */
              
                              #if(UART_PS2_TXCLKGEN_DP)
                                  txPeriod = UART_PS2_TXBITCLKTX_COMPLETE_REG;
                                  UART_PS2_TXBITCLKTX_COMPLETE_REG = UART_PS2_TXBITCTR_BREAKBITS;
                              #else
                                  txPeriod = UART_PS2_TXBITCTR_PERIOD_REG;
                                  UART_PS2_TXBITCTR_PERIOD_REG = UART_PS2_TXBITCTR_BREAKBITS8X;
                              #endif /* End UART_PS2_TXCLKGEN_DP */
              
                              /* Send zeros */
                              UART_PS2_TXDATA_REG = 0u;
              
                              do /* Wait until transmit starts */
                              {
                                  tmpStat = UART_PS2_TXSTATUS_REG;
                              }
                              while((tmpStat & UART_PS2_TX_STS_FIFO_EMPTY) != 0u);
                          }
              
                          if( (retMode == UART_PS2_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_PS2_SEND_WAIT_REINIT) )
                          {
                              do /* Wait until transmit complete */
                              {
                                  tmpStat = UART_PS2_TXSTATUS_REG;
                              }
                              while(((uint8)~tmpStat & UART_PS2_TX_STS_COMPLETE) != 0u);
                          }
              
                          if( (retMode == UART_PS2_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_PS2_REINIT) ||
                              (retMode == UART_PS2_SEND_WAIT_REINIT) )
                          {
              
                          #if(UART_PS2_TXCLKGEN_DP)
                              UART_PS2_TXBITCLKTX_COMPLETE_REG = txPeriod;
                          #else
                              UART_PS2_TXBITCTR_PERIOD_REG = txPeriod;
                          #endif /* End UART_PS2_TXCLKGEN_DP */
              
                          #if( (UART_PS2_PARITY_TYPE != UART_PS2__B_UART__NONE_REVB) || \
                               (UART_PS2_PARITY_TYPE_SW != 0u) )
                              UART_PS2_WriteControlRegister(UART_PS2_ReadControlRegister() &
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 26  

                                                                    (uint8) ~UART_PS2_CTRL_HD_SEND_BREAK);
                          #endif /* End UART_PS2_PARITY_TYPE != NONE */
                          }
                      #endif    /* End UART_PS2_HD_ENABLED */
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_SetTxAddressMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the transmitter to signal the next bytes is address or data.
                  *
                  * Parameters:
                  *  addressMode: 
                  *       UART_PS2_SET_SPACE - Configure the transmitter to send the next
                  *                                    byte as a data.
                  *       UART_PS2_SET_MARK  - Configure the transmitter to send the next
                  *                                    byte as an address.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  This function sets and clears UART_PS2_CTRL_MARK bit in the Control
                  *  register.
                  *
                  *******************************************************************************/
                  void UART_PS2_SetTxAddressMode(uint8 addressMode) 
                  {
                      /* Mark/Space sending enable */
                      if(addressMode != 0u)
                      {
                      #if( UART_PS2_CONTROL_REG_REMOVED == 0u )
                          UART_PS2_WriteControlRegister(UART_PS2_ReadControlRegister() |
                                                                UART_PS2_CTRL_MARK);
                      #endif /* End UART_PS2_CONTROL_REG_REMOVED == 0u */
                      }
                      else
                      {
                      #if( UART_PS2_CONTROL_REG_REMOVED == 0u )
                          UART_PS2_WriteControlRegister(UART_PS2_ReadControlRegister() &
                                                                (uint8) ~UART_PS2_CTRL_MARK);
                      #endif /* End UART_PS2_CONTROL_REG_REMOVED == 0u */
                      }
                  }
              
              #endif  /* EndUART_PS2_TX_ENABLED */
1592          
1593          #if(UART_PS2_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the receiver configuration in half duplex mode. After calling this
                  *  function, the UART is ready to receive data.
                  *
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 27  

                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the transmitter
                  *  configuration.
                  *
                  *******************************************************************************/
                  void UART_PS2_LoadRxConfig(void) 
                  {
                      UART_PS2_WriteControlRegister(UART_PS2_ReadControlRegister() &
                                                              (uint8)~UART_PS2_CTRL_HD_SEND);
                      UART_PS2_RXBITCTR_PERIOD_REG = UART_PS2_HD_RXBITCTR_INIT;
              
                  #if (UART_PS2_RX_INTERRUPT_ENABLED)
                      /* Enable RX interrupt after set RX configuration */
                      UART_PS2_SetRxInterruptMode(UART_PS2_INIT_RX_INTERRUPTS_MASK);
                  #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_PS2_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the transmitter configuration in half duplex mode. After calling this
                  *  function, the UART is ready to transmit data.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the receiver configuration.
                  *
                  *******************************************************************************/
                  void UART_PS2_LoadTxConfig(void) 
                  {
                  #if (UART_PS2_RX_INTERRUPT_ENABLED)
                      /* Disable RX interrupts before set TX configuration */
                      UART_PS2_SetRxInterruptMode(0u);
                  #endif /* (UART_PS2_RX_INTERRUPT_ENABLED) */
              
                      UART_PS2_WriteControlRegister(UART_PS2_ReadControlRegister() | UART_PS2_CTRL_HD_SEND);
                      UART_PS2_RXBITCTR_PERIOD_REG = UART_PS2_HD_TXBITCTR_INIT;
                  }
              
              #endif  /* UART_PS2_HD_ENABLED */
1660          
1661          
1662          /* [] END OF FILE */
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 28  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_PS2_Start (BEGIN)
                                           ; SOURCE LINE # 76
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 79
0000 900000      R     MOV     DPTR,#UART_PS2_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 80
                                           ; SOURCE LINE # 81
0008 120000      R     LCALL   UART_PS2_Init
                                           ; SOURCE LINE # 82
000B 900000      R     MOV     DPTR,#UART_PS2_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 83
0011         ?C0001:
                                           ; SOURCE LINE # 85
0011 120000      R     LCALL   UART_PS2_Enable
                                           ; SOURCE LINE # 86
0014 22                RET     
             ; FUNCTION UART_PS2_Start (END)

             ; FUNCTION UART_PS2_Init (BEGIN)
                                           ; SOURCE LINE # 106
                                           ; SOURCE LINE # 107
                                           ; SOURCE LINE # 124
0000 906487            MOV     DPTR,#06487H
0003 7472              MOV     A,#072H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
0006 906587            MOV     DPTR,#06587H
0009 742A              MOV     A,#02AH
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
000C 22                RET     
             ; FUNCTION UART_PS2_Init (END)

             ; FUNCTION UART_PS2_Enable (BEGIN)
                                           ; SOURCE LINE # 183
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 186
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 190
0008 906497            MOV     DPTR,#06497H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4420              ORL     A,#020H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 193
0013 906597            MOV     DPTR,#06597H
0016 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 29  

0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4410              ORL     A,#010H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 219
001E 120000      E     LCALL   UART_PS2_IntClock_Start
                                           ; SOURCE LINE # 222
0021 900000      R     MOV     DPTR,#enableInterrupts
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 223
0029 22                RET     
             ; FUNCTION UART_PS2_Enable (END)

             ; FUNCTION UART_PS2_Stop (BEGIN)
                                           ; SOURCE LINE # 240
                                           ; SOURCE LINE # 241
                                           ; SOURCE LINE # 243
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 247
0008 906497            MOV     DPTR,#06497H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54DF              ANL     A,#0DFH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 257
0013 120000      E     LCALL   UART_PS2_IntClock_Stop
                                           ; SOURCE LINE # 262
0016 906597            MOV     DPTR,#06597H
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C 54EF              ANL     A,#0EFH
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
0021 900000      R     MOV     DPTR,#enableInterrupts
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 278
0029 22                RET     
             ; FUNCTION UART_PS2_Stop (END)

             ; FUNCTION UART_PS2_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 298
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 302
0002         ?C0006:
0002 22                RET     
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 30  

             ; FUNCTION UART_PS2_ReadControlRegister (END)

             ; FUNCTION _UART_PS2_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 319
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 322
                                           ; SOURCE LINE # 323
                                           ; SOURCE LINE # 325
                                           ; SOURCE LINE # 329
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _UART_PS2_WriteControlRegister (END)

             ; FUNCTION _UART_PS2_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 359
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 361
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906587            MOV     DPTR,#06587H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 362
000F 22                RET     
             ; FUNCTION _UART_PS2_SetRxInterruptMode (END)

             ; FUNCTION UART_PS2_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 392
                                           ; SOURCE LINE # 393
                                           ; SOURCE LINE # 448
0000 906547            MOV     DPTR,#06547H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#rxData
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 452
000A 900000      R     MOV     DPTR,#rxData
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
                                           ; SOURCE LINE # 453
000F         ?C0010:
000F 22                RET     
             ; FUNCTION UART_PS2_ReadRxData (END)

             ; FUNCTION UART_PS2_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 485
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 489
0000 906567            MOV     DPTR,#06567H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 31  

0009 900000      R     MOV     DPTR,#status
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 499
000E 900000      R     MOV     DPTR,#status
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
                                           ; SOURCE LINE # 500
0013         ?C0011:
0013 22                RET     
             ; FUNCTION UART_PS2_ReadRxStatus (END)

             ; FUNCTION UART_PS2_GetChar (BEGIN)
                                           ; SOURCE LINE # 532
                                           ; SOURCE LINE # 533
                                           ; SOURCE LINE # 534
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 596
0005 906567            MOV     DPTR,#06567H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#rxStatus
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 597
000F 900000      R     MOV     DPTR,#rxStatus
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 30E51E            JNB     ACC.5,?C0012
                                           ; SOURCE LINE # 598
                                           ; SOURCE LINE # 600
0018 906547            MOV     DPTR,#06547H
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#rxData
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 604
0022 900000      R     MOV     DPTR,#rxStatus
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 541E              ANL     A,#01EH
002A FF                MOV     R7,A
002B 7E00              MOV     R6,#00H
002D EF                MOV     A,R7
002E 4E                ORL     A,R6
002F 6005              JZ      ?C0012
                                           ; SOURCE LINE # 605
                                           ; SOURCE LINE # 606
0031 900000      R     MOV     DPTR,#rxData
0034 E4                CLR     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 607
                                           ; SOURCE LINE # 608
0036         ?C0012:
                                           ; SOURCE LINE # 611
0036 900000      R     MOV     DPTR,#rxData
0039 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 32  

003A FF                MOV     R7,A
                                           ; SOURCE LINE # 612
003B         ?C0014:
003B 22                RET     
             ; FUNCTION UART_PS2_GetChar (END)

             ; FUNCTION UART_PS2_GetByte (BEGIN)
                                           ; SOURCE LINE # 634
                                           ; SOURCE LINE # 635
                                           ; SOURCE LINE # 646
0000 120000      R     LCALL   UART_PS2_ReadRxStatus
0003 7E00              MOV     R6,#00H
0005 EF                MOV     A,R7
0006 7D00              MOV     R5,#00H
0008 FC                MOV     R4,A
0009 120000      R     LCALL   UART_PS2_ReadRxData
000C 7E00              MOV     R6,#00H
000E EC                MOV     A,R4
000F 4E                ORL     A,R6
0010 FE                MOV     R6,A
0011 ED                MOV     A,R5
0012 4F                ORL     A,R7
0013 FF                MOV     R7,A
                                           ; SOURCE LINE # 649
0014         ?C0015:
0014 22                RET     
             ; FUNCTION UART_PS2_GetByte (END)

             ; FUNCTION UART_PS2_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 683
                                           ; SOURCE LINE # 685
                                           ; SOURCE LINE # 718
0000 906567            MOV     DPTR,#06567H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E504            JNB     ACC.5,?C0016
0009 7F01              MOV     R7,#01H
000B 8002              SJMP    ?C0017
000D         ?C0016:
000D 7F00              MOV     R7,#00H
000F         ?C0017:
000F 900000      R     MOV     DPTR,#size
0012 EF                MOV     A,R7
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 722
0014 900000      R     MOV     DPTR,#size
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
                                           ; SOURCE LINE # 723
0019         ?C0018:
0019 22                RET     
             ; FUNCTION UART_PS2_GetRxBufferSize (END)

             ; FUNCTION UART_PS2_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 757
                                           ; SOURCE LINE # 758
                                           ; SOURCE LINE # 762
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 33  

                                           ; SOURCE LINE # 763
0008 906597            MOV     DPTR,#06597H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 764
0013 906597            MOV     DPTR,#06597H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 781
0026 22                RET     
             ; FUNCTION UART_PS2_ClearRxBuffer (END)

             ; FUNCTION _UART_PS2_SetRxAddressMode (BEGIN)
                                           ; SOURCE LINE # 813
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 815
                                           ; SOURCE LINE # 835
                                           ; SOURCE LINE # 836
                                           ; SOURCE LINE # 838
                                           ; SOURCE LINE # 840
0005         ?C0021:
0005 22                RET     
             ; FUNCTION _UART_PS2_SetRxAddressMode (END)

             ; FUNCTION _UART_PS2_SetRxAddress1 (BEGIN)
                                           ; SOURCE LINE # 857
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 858
                                           ; SOURCE LINE # 859
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906527            MOV     DPTR,#06527H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 860
000F 22                RET     
             ; FUNCTION _UART_PS2_SetRxAddress1 (END)

             ; FUNCTION _UART_PS2_SetRxAddress2 (BEGIN)
                                           ; SOURCE LINE # 877
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
C51 COMPILER V9.51   UART_PS2                                                              12/05/2015 15:02:20 PAGE 34  

0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 878
                                           ; SOURCE LINE # 879
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906537            MOV     DPTR,#06537H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 880
000F 22                RET     
             ; FUNCTION _UART_PS2_SetRxAddress2 (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    363    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
