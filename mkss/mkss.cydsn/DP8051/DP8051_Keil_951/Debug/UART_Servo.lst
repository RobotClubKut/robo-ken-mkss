C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_SERVO
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\UART_Servo.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\UART_Servo.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DEB
                    -UG) WL(2) PR(.\DP8051\DP8051_Keil_951\Debug/UART_Servo.lst) CD OT(2,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\UART_Servo.o
                    -bj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART_Servo.c
   3          * Version 2.50
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART_Servo.h"
  18          #if (UART_Servo_INTERNAL_CLOCK_USED)
  19              #include "UART_Servo_IntClock.h"
  20          #endif /* End UART_Servo_INTERNAL_CLOCK_USED */
  21          
  22          
  23          /***************************************
  24          * Global data allocation
  25          ***************************************/
  26          
  27          uint8 UART_Servo_initVar = 0u;
  28          
  29          #if (UART_Servo_TX_INTERRUPT_ENABLED && UART_Servo_TX_ENABLED)
                  volatile uint8 UART_Servo_txBuffer[UART_Servo_TX_BUFFER_SIZE];
                  volatile uint8 UART_Servo_txBufferRead = 0u;
                  uint8 UART_Servo_txBufferWrite = 0u;
              #endif /* (UART_Servo_TX_INTERRUPT_ENABLED && UART_Servo_TX_ENABLED) */
  34          
  35          #if (UART_Servo_RX_INTERRUPT_ENABLED && (UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED))
  36              uint8 UART_Servo_errorStatus = 0u;
  37              volatile uint8 UART_Servo_rxBuffer[UART_Servo_RX_BUFFER_SIZE];
  38              volatile uint8 UART_Servo_rxBufferRead  = 0u;
  39              volatile uint8 UART_Servo_rxBufferWrite = 0u;
  40              volatile uint8 UART_Servo_rxBufferLoopDetect = 0u;
  41              volatile uint8 UART_Servo_rxBufferOverflow   = 0u;
  42              #if (UART_Servo_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_Servo_rxAddressMode = UART_Servo_RX_ADDRESS_MODE;
                      volatile uint8 UART_Servo_rxAddressDetected = 0u;
                  #endif /* (UART_Servo_RXHW_ADDRESS_ENABLED) */
  46          #endif /* (UART_Servo_RX_INTERRUPT_ENABLED && (UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED)) */
  47          
  48          
  49          /*******************************************************************************
  50          * Function Name: UART_Servo_Start
  51          ********************************************************************************
  52          *
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 2   

  53          * Summary:
  54          *  This is the preferred method to begin component operation.
  55          *  UART_Servo_Start() sets the initVar variable, calls the
  56          *  UART_Servo_Init() function, and then calls the
  57          *  UART_Servo_Enable() function.
  58          *
  59          * Parameters:
  60          *  None.
  61          *
  62          * Return:
  63          *  None.
  64          *
  65          * Global variables:
  66          *  The UART_Servo_intiVar variable is used to indicate initial
  67          *  configuration of this component. The variable is initialized to zero (0u)
  68          *  and set to one (1u) the first time UART_Servo_Start() is called. This
  69          *  allows for component initialization without re-initialization in all
  70          *  subsequent calls to the UART_Servo_Start() routine.
  71          *
  72          * Reentrant:
  73          *  No.
  74          *
  75          *******************************************************************************/
  76          void UART_Servo_Start(void) 
  77          {
  78   1          /* If not initialized then initialize all required hardware and software */
  79   1          if(UART_Servo_initVar == 0u)
  80   1          {
  81   2              UART_Servo_Init();
  82   2              UART_Servo_initVar = 1u;
  83   2          }
  84   1      
  85   1          UART_Servo_Enable();
  86   1      }
  87          
  88          
  89          /*******************************************************************************
  90          * Function Name: UART_Servo_Init
  91          ********************************************************************************
  92          *
  93          * Summary:
  94          *  Initializes or restores the component according to the customizer Configure
  95          *  dialog settings. It is not necessary to call UART_Servo_Init() because
  96          *  the UART_Servo_Start() API calls this function and is the preferred
  97          *  method to begin component operation.
  98          *
  99          * Parameters:
 100          *  None.
 101          *
 102          * Return:
 103          *  None.
 104          *
 105          *******************************************************************************/
 106          void UART_Servo_Init(void) 
 107          {
 108   1          #if(UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED)
 109   1      
 110   1              #if (UART_Servo_RX_INTERRUPT_ENABLED)
 111   1                  /* Set RX interrupt vector and priority */
 112   1                  (void) CyIntSetVector(UART_Servo_RX_VECT_NUM, &UART_Servo_RXISR);
 113   1                  CyIntSetPriority(UART_Servo_RX_VECT_NUM, UART_Servo_RX_PRIOR_NUM);
 114   1                  UART_Servo_errorStatus = 0u;
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 3   

 115   1              #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
 116   1      
 117   1              #if (UART_Servo_RXHW_ADDRESS_ENABLED)
                          UART_Servo_SetRxAddressMode(UART_Servo_RX_ADDRESS_MODE);
                          UART_Servo_SetRxAddress1(UART_Servo_RX_HW_ADDRESS1);
                          UART_Servo_SetRxAddress2(UART_Servo_RX_HW_ADDRESS2);
                      #endif /* End UART_Servo_RXHW_ADDRESS_ENABLED */
 122   1      
 123   1              /* Init Count7 period */
 124   1              UART_Servo_RXBITCTR_PERIOD_REG = UART_Servo_RXBITCTR_INIT;
 125   1              /* Configure the Initial RX interrupt mask */
 126   1              UART_Servo_RXSTATUS_MASK_REG  = UART_Servo_INIT_RX_INTERRUPTS_MASK;
 127   1          #endif /* End UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED*/
 128   1      
 129   1          #if(UART_Servo_TX_ENABLED)
 130   1              #if (UART_Servo_TX_INTERRUPT_ENABLED)
                          /* Set TX interrupt vector and priority */
                          (void) CyIntSetVector(UART_Servo_TX_VECT_NUM, &UART_Servo_TXISR);
                          CyIntSetPriority(UART_Servo_TX_VECT_NUM, UART_Servo_TX_PRIOR_NUM);
                      #endif /* (UART_Servo_TX_INTERRUPT_ENABLED) */
 135   1      
 136   1              /* Write Counter Value for TX Bit Clk Generator*/
 137   1              #if (UART_Servo_TXCLKGEN_DP)
 138   1                  UART_Servo_TXBITCLKGEN_CTR_REG = UART_Servo_BIT_CENTER;
 139   1                  UART_Servo_TXBITCLKTX_COMPLETE_REG = ((UART_Servo_NUMBER_OF_DATA_BITS +
 140   1                              UART_Servo_NUMBER_OF_START_BIT) * UART_Servo_OVER_SAMPLE_COUNT) - 1u;
 141   1              #else
                          UART_Servo_TXBITCTR_PERIOD_REG = ((UART_Servo_NUMBER_OF_DATA_BITS +
                                      UART_Servo_NUMBER_OF_START_BIT) * UART_Servo_OVER_SAMPLE_8) - 1u;
                      #endif /* End UART_Servo_TXCLKGEN_DP */
 145   1      
 146   1              /* Configure the Initial TX interrupt mask */
 147   1              #if (UART_Servo_TX_INTERRUPT_ENABLED)
                          UART_Servo_TXSTATUS_MASK_REG = UART_Servo_TX_STS_FIFO_EMPTY;
                      #else
 150   1                  UART_Servo_TXSTATUS_MASK_REG = UART_Servo_INIT_TX_INTERRUPTS_MASK;
 151   1              #endif /*End UART_Servo_TX_INTERRUPT_ENABLED*/
 152   1      
 153   1          #endif /* End UART_Servo_TX_ENABLED */
 154   1      
 155   1          #if(UART_Servo_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_Servo_WriteControlRegister( \
                          (UART_Servo_ReadControlRegister() & (uint8)~UART_Servo_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(UART_Servo_PARITY_TYPE << UART_Servo_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_Servo_PARITY_TYPE_SW */
 160   1      }
 161          
 162          
 163          /*******************************************************************************
 164          * Function Name: UART_Servo_Enable
 165          ********************************************************************************
 166          *
 167          * Summary:
 168          *  Activates the hardware and begins component operation. It is not necessary
 169          *  to call UART_Servo_Enable() because the UART_Servo_Start() API
 170          *  calls this function, which is the preferred method to begin component
 171          *  operation.
 172          
 173          * Parameters:
 174          *  None.
 175          *
 176          * Return:
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 4   

 177          *  None.
 178          *
 179          * Global Variables:
 180          *  UART_Servo_rxAddressDetected - set to initial state (0).
 181          *
 182          *******************************************************************************/
 183          void UART_Servo_Enable(void) 
 184          {
 185   1          uint8 enableInterrupts;
 186   1          enableInterrupts = CyEnterCriticalSection();
 187   1      
 188   1          #if (UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED)
 189   1              /* RX Counter (Count7) Enable */
 190   1              UART_Servo_RXBITCTR_CONTROL_REG |= UART_Servo_CNTR_ENABLE;
 191   1      
 192   1              /* Enable the RX Interrupt */
 193   1              UART_Servo_RXSTATUS_ACTL_REG  |= UART_Servo_INT_ENABLE;
 194   1      
 195   1              #if (UART_Servo_RX_INTERRUPT_ENABLED)
 196   1                  UART_Servo_EnableRxInt();
 197   1      
 198   1                  #if (UART_Servo_RXHW_ADDRESS_ENABLED)
                              UART_Servo_rxAddressDetected = 0u;
                          #endif /* (UART_Servo_RXHW_ADDRESS_ENABLED) */
 201   1              #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
 202   1          #endif /* (UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED) */
 203   1      
 204   1          #if(UART_Servo_TX_ENABLED)
 205   1              /* TX Counter (DP/Count7) Enable */
 206   1              #if(!UART_Servo_TXCLKGEN_DP)
                          UART_Servo_TXBITCTR_CONTROL_REG |= UART_Servo_CNTR_ENABLE;
                      #endif /* End UART_Servo_TXCLKGEN_DP */
 209   1      
 210   1              /* Enable the TX Interrupt */
 211   1              UART_Servo_TXSTATUS_ACTL_REG |= UART_Servo_INT_ENABLE;
 212   1              #if (UART_Servo_TX_INTERRUPT_ENABLED)
                          UART_Servo_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
                          UART_Servo_EnableTxInt();
                      #endif /* (UART_Servo_TX_INTERRUPT_ENABLED) */
 216   1           #endif /* (UART_Servo_TX_INTERRUPT_ENABLED) */
 217   1      
 218   1          #if (UART_Servo_INTERNAL_CLOCK_USED)
 219   1              UART_Servo_IntClock_Start();  /* Enable the clock */
 220   1          #endif /* (UART_Servo_INTERNAL_CLOCK_USED) */
 221   1      
 222   1          CyExitCriticalSection(enableInterrupts);
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: UART_Servo_Stop
 228          ********************************************************************************
 229          *
 230          * Summary:
 231          *  Disables the UART operation.
 232          *
 233          * Parameters:
 234          *  None.
 235          *
 236          * Return:
 237          *  None.
 238          *
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 5   

 239          *******************************************************************************/
 240          void UART_Servo_Stop(void) 
 241          {
 242   1          uint8 enableInterrupts;
 243   1          enableInterrupts = CyEnterCriticalSection();
 244   1      
 245   1          /* Write Bit Counter Disable */
 246   1          #if (UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED)
 247   1              UART_Servo_RXBITCTR_CONTROL_REG &= (uint8) ~UART_Servo_CNTR_ENABLE;
 248   1          #endif /* (UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED) */
 249   1      
 250   1          #if (UART_Servo_TX_ENABLED)
 251   1              #if(!UART_Servo_TXCLKGEN_DP)
                          UART_Servo_TXBITCTR_CONTROL_REG &= (uint8) ~UART_Servo_CNTR_ENABLE;
                      #endif /* (!UART_Servo_TXCLKGEN_DP) */
 254   1          #endif /* (UART_Servo_TX_ENABLED) */
 255   1      
 256   1          #if (UART_Servo_INTERNAL_CLOCK_USED)
 257   1              UART_Servo_IntClock_Stop();   /* Disable the clock */
 258   1          #endif /* (UART_Servo_INTERNAL_CLOCK_USED) */
 259   1      
 260   1          /* Disable internal interrupt component */
 261   1          #if (UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED)
 262   1              UART_Servo_RXSTATUS_ACTL_REG  &= (uint8) ~UART_Servo_INT_ENABLE;
 263   1      
 264   1              #if (UART_Servo_RX_INTERRUPT_ENABLED)
 265   1                  UART_Servo_DisableRxInt();
 266   1              #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
 267   1          #endif /* (UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED) */
 268   1      
 269   1          #if (UART_Servo_TX_ENABLED)
 270   1              UART_Servo_TXSTATUS_ACTL_REG &= (uint8) ~UART_Servo_INT_ENABLE;
 271   1      
 272   1              #if (UART_Servo_TX_INTERRUPT_ENABLED)
                          UART_Servo_DisableTxInt();
                      #endif /* (UART_Servo_TX_INTERRUPT_ENABLED) */
 275   1          #endif /* (UART_Servo_TX_ENABLED) */
 276   1      
 277   1          CyExitCriticalSection(enableInterrupts);
 278   1      }
 279          
 280          
 281          /*******************************************************************************
 282          * Function Name: UART_Servo_ReadControlRegister
 283          ********************************************************************************
 284          *
 285          * Summary:
 286          *  Returns the current value of the control register.
 287          *
 288          * Parameters:
 289          *  None.
 290          *
 291          * Return:
 292          *  Contents of the control register.
 293          *
 294          *******************************************************************************/
 295          uint8 UART_Servo_ReadControlRegister(void) 
 296          {
 297   1          #if (UART_Servo_CONTROL_REG_REMOVED)
 298   1              return(0u);
 299   1          #else
                      return(UART_Servo_CONTROL_REG);
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 6   

                  #endif /* (UART_Servo_CONTROL_REG_REMOVED) */
 302   1      }
 303          
 304          
 305          /*******************************************************************************
 306          * Function Name: UART_Servo_WriteControlRegister
 307          ********************************************************************************
 308          *
 309          * Summary:
 310          *  Writes an 8-bit value into the control register
 311          *
 312          * Parameters:
 313          *  control:  control register value
 314          *
 315          * Return:
 316          *  None.
 317          *
 318          *******************************************************************************/
 319          void  UART_Servo_WriteControlRegister(uint8 control) 
 320          {
 321   1          #if (UART_Servo_CONTROL_REG_REMOVED)
 322   1              if(0u != control)
 323   1              {
 324   2                  /* Suppress compiler warning */
 325   2              }
 326   1          #else
                     UART_Servo_CONTROL_REG = control;
                  #endif /* (UART_Servo_CONTROL_REG_REMOVED) */
 329   1      }
 330          
 331          
 332          #if(UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED)
 333              /*******************************************************************************
 334              * Function Name: UART_Servo_SetRxInterruptMode
 335              ********************************************************************************
 336              *
 337              * Summary:
 338              *  Configures the RX interrupt sources enabled.
 339              *
 340              * Parameters:
 341              *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
 342              *  bit-field arrangement of the status register. This value must be a 
 343              *  combination of status register bit-masks shown below:
 344              *      UART_Servo_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
 345              *      UART_Servo_RX_STS_PAR_ERROR        Interrupt on parity error.
 346              *      UART_Servo_RX_STS_STOP_ERROR       Interrupt on stop error.
 347              *      UART_Servo_RX_STS_BREAK            Interrupt on break.
 348              *      UART_Servo_RX_STS_OVERRUN          Interrupt on overrun error.
 349              *      UART_Servo_RX_STS_ADDR_MATCH       Interrupt on address match.
 350              *      UART_Servo_RX_STS_MRKSPC           Interrupt on address detect.
 351              *
 352              * Return:
 353              *  None.
 354              *
 355              * Theory:
 356              *  Enables the output of specific status bits to the interrupt controller
 357              *
 358              *******************************************************************************/
 359              void UART_Servo_SetRxInterruptMode(uint8 intSrc) 
 360              {
 361   1              UART_Servo_RXSTATUS_MASK_REG  = intSrc;
 362   1          }
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 7   

 363          
 364          
 365              /*******************************************************************************
 366              * Function Name: UART_Servo_ReadRxData
 367              ********************************************************************************
 368              *
 369              * Summary:
 370              *  Returns the next byte of received data. This function returns data without
 371              *  checking the status. You must check the status separately.
 372              *
 373              * Parameters:
 374              *  None.
 375              *
 376              * Return:
 377              *  Received data from RX register
 378              *
 379              * Global Variables:
 380              *  UART_Servo_rxBuffer - RAM buffer pointer for save received data.
 381              *  UART_Servo_rxBufferWrite - cyclic index for write to rxBuffer,
 382              *     checked to identify new data.
 383              *  UART_Servo_rxBufferRead - cyclic index for read from rxBuffer,
 384              *     incremented after each byte has been read from buffer.
 385              *  UART_Servo_rxBufferLoopDetect - cleared if loop condition was detected
 386              *     in RX ISR.
 387              *
 388              * Reentrant:
 389              *  No.
 390              *
 391              *******************************************************************************/
 392              uint8 UART_Servo_ReadRxData(void) 
 393              {
 394   1              uint8 rxData;
 395   1      
 396   1          #if (UART_Servo_RX_INTERRUPT_ENABLED)
 397   1      
 398   1              uint8 locRxBufferRead;
 399   1              uint8 locRxBufferWrite;
 400   1      
 401   1              /* Protect variables that could change on interrupt */
 402   1              UART_Servo_DisableRxInt();
 403   1      
 404   1              locRxBufferRead  = UART_Servo_rxBufferRead;
 405   1              locRxBufferWrite = UART_Servo_rxBufferWrite;
 406   1      
 407   1              if( (UART_Servo_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 408   1              {
 409   2                  rxData = UART_Servo_rxBuffer[locRxBufferRead];
 410   2                  locRxBufferRead++;
 411   2      
 412   2                  if(locRxBufferRead >= UART_Servo_RX_BUFFER_SIZE)
 413   2                  {
 414   3                      locRxBufferRead = 0u;
 415   3                  }
 416   2                  /* Update the real pointer */
 417   2                  UART_Servo_rxBufferRead = locRxBufferRead;
 418   2      
 419   2                  if(UART_Servo_rxBufferLoopDetect != 0u)
 420   2                  {
 421   3                      UART_Servo_rxBufferLoopDetect = 0u;
 422   3                      #if ((UART_Servo_RX_INTERRUPT_ENABLED) && (UART_Servo_FLOW_CONTROL != 0u))
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_Servo_HD_ENABLED )
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 8   

                                      if((UART_Servo_CONTROL_REG & UART_Servo_CTRL_HD_SEND) == 0u)
                                      {   /* In Half duplex mode return RX mask only in RX
                                          *  configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_Servo_RXSTATUS_MASK_REG  |= UART_Servo_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_Servo_RXSTATUS_MASK_REG  |= UART_Servo_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_Servo_HD_ENABLED */
                              #endif /* ((UART_Servo_RX_INTERRUPT_ENABLED) && (UART_Servo_FLOW_CONTROL != 0u)) */
 436   3                  }
 437   2              }
 438   1              else
 439   1              {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
 440   2                  rxData = UART_Servo_RXDATA_REG;
 441   2              }
 442   1      
 443   1              UART_Servo_EnableRxInt();
 444   1      
 445   1          #else
              
                      /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
                      rxData = UART_Servo_RXDATA_REG;
              
                  #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
 451   1      
 452   1              return(rxData);
 453   1          }
 454          
 455          
 456              /*******************************************************************************
 457              * Function Name: UART_Servo_ReadRxStatus
 458              ********************************************************************************
 459              *
 460              * Summary:
 461              *  Returns the current state of the receiver status register and the software
 462              *  buffer overflow status.
 463              *
 464              * Parameters:
 465              *  None.
 466              *
 467              * Return:
 468              *  Current state of the status register.
 469              *
 470              * Side Effect:
 471              *  All status register bits are clear-on-read except
 472              *  UART_Servo_RX_STS_FIFO_NOTEMPTY.
 473              *  UART_Servo_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
 474              *  register read.
 475              *
 476              * Global Variables:
 477              *  UART_Servo_rxBufferOverflow - used to indicate overload condition.
 478              *   It set to one in RX interrupt when there isn't free space in
 479              *   UART_Servo_rxBufferRead to write new data. This condition returned
 480              *   and cleared to zero by this API as an
 481              *   UART_Servo_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
 482              *   bits.
 483              *
 484              *******************************************************************************/
 485              uint8 UART_Servo_ReadRxStatus(void) 
 486              {
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 9   

 487   1              uint8 status;
 488   1      
 489   1              status = UART_Servo_RXSTATUS_REG & UART_Servo_RX_HW_MASK;
 490   1      
 491   1          #if (UART_Servo_RX_INTERRUPT_ENABLED)
 492   1              if(UART_Servo_rxBufferOverflow != 0u)
 493   1              {
 494   2                  status |= UART_Servo_RX_STS_SOFT_BUFF_OVER;
 495   2                  UART_Servo_rxBufferOverflow = 0u;
 496   2              }
 497   1          #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
 498   1      
 499   1              return(status);
 500   1          }
 501          
 502          
 503              /*******************************************************************************
 504              * Function Name: UART_Servo_GetChar
 505              ********************************************************************************
 506              *
 507              * Summary:
 508              *  Returns the last received byte of data. UART_Servo_GetChar() is
 509              *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
 510              *  for valid characters and 0 indicates an error occurred or no data is present.
 511              *
 512              * Parameters:
 513              *  None.
 514              *
 515              * Return:
 516              *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
 517              *  A returned zero signifies an error condition or no data available.
 518              *
 519              * Global Variables:
 520              *  UART_Servo_rxBuffer - RAM buffer pointer for save received data.
 521              *  UART_Servo_rxBufferWrite - cyclic index for write to rxBuffer,
 522              *     checked to identify new data.
 523              *  UART_Servo_rxBufferRead - cyclic index for read from rxBuffer,
 524              *     incremented after each byte has been read from buffer.
 525              *  UART_Servo_rxBufferLoopDetect - cleared if loop condition was detected
 526              *     in RX ISR.
 527              *
 528              * Reentrant:
 529              *  No.
 530              *
 531              *******************************************************************************/
 532              uint8 UART_Servo_GetChar(void) 
 533              {
 534   1              uint8 rxData = 0u;
 535   1              uint8 rxStatus;
 536   1      
 537   1          #if (UART_Servo_RX_INTERRUPT_ENABLED)
 538   1              uint8 locRxBufferRead;
 539   1              uint8 locRxBufferWrite;
 540   1      
 541   1              /* Protect variables that could change on interrupt */
 542   1              UART_Servo_DisableRxInt();
 543   1      
 544   1              locRxBufferRead  = UART_Servo_rxBufferRead;
 545   1              locRxBufferWrite = UART_Servo_rxBufferWrite;
 546   1      
 547   1              if( (UART_Servo_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
 548   1              {
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 10  

 549   2                  rxData = UART_Servo_rxBuffer[locRxBufferRead];
 550   2                  locRxBufferRead++;
 551   2                  if(locRxBufferRead >= UART_Servo_RX_BUFFER_SIZE)
 552   2                  {
 553   3                      locRxBufferRead = 0u;
 554   3                  }
 555   2                  /* Update the real pointer */
 556   2                  UART_Servo_rxBufferRead = locRxBufferRead;
 557   2      
 558   2                  if(UART_Servo_rxBufferLoopDetect != 0u)
 559   2                  {
 560   3                      UART_Servo_rxBufferLoopDetect = 0u;
 561   3                      #if( (UART_Servo_RX_INTERRUPT_ENABLED) && (UART_Servo_FLOW_CONTROL != 0u) )
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_Servo_HD_ENABLED )
                                      if((UART_Servo_CONTROL_REG & UART_Servo_CTRL_HD_SEND) == 0u)
                                      {   /* In Half duplex mode return RX mask only if
                                          *  RX configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_Servo_RXSTATUS_MASK_REG |= UART_Servo_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_Servo_RXSTATUS_MASK_REG |= UART_Servo_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_Servo_HD_ENABLED */
                              #endif /* UART_Servo_RX_INTERRUPT_ENABLED and Hardware flow control*/
 575   3                  }
 576   2      
 577   2              }
 578   1              else
 579   1              {   rxStatus = UART_Servo_RXSTATUS_REG;
 580   2                  if((rxStatus & UART_Servo_RX_STS_FIFO_NOTEMPTY) != 0u)
 581   2                  {   /* Read received data from FIFO */
 582   3                      rxData = UART_Servo_RXDATA_REG;
 583   3                      /*Check status on error*/
 584   3                      if((rxStatus & (UART_Servo_RX_STS_BREAK | UART_Servo_RX_STS_PAR_ERROR |
 585   3                                      UART_Servo_RX_STS_STOP_ERROR | UART_Servo_RX_STS_OVERRUN)) != 0u)
 586   3                      {
 587   4                          rxData = 0u;
 588   4                      }
 589   3                  }
 590   2              }
 591   1      
 592   1              UART_Servo_EnableRxInt();
 593   1      
 594   1          #else
              
                      rxStatus =UART_Servo_RXSTATUS_REG;
                      if((rxStatus & UART_Servo_RX_STS_FIFO_NOTEMPTY) != 0u)
                      {
                          /* Read received data from FIFO */
                          rxData = UART_Servo_RXDATA_REG;
              
                          /*Check status on error*/
                          if((rxStatus & (UART_Servo_RX_STS_BREAK | UART_Servo_RX_STS_PAR_ERROR |
                                          UART_Servo_RX_STS_STOP_ERROR | UART_Servo_RX_STS_OVERRUN)) != 0u)
                          {
                              rxData = 0u;
                          }
                      }
                  #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
 610   1      
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 11  

 611   1              return(rxData);
 612   1          }
 613          
 614          
 615              /*******************************************************************************
 616              * Function Name: UART_Servo_GetByte
 617              ********************************************************************************
 618              *
 619              * Summary:
 620              *  Reads UART RX buffer immediately, returns received character and error
 621              *  condition.
 622              *
 623              * Parameters:
 624              *  None.
 625              *
 626              * Return:
 627              *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
 628              *  an error has occurred.
 629              *
 630              * Reentrant:
 631              *  No.
 632              *
 633              *******************************************************************************/
 634              uint16 UART_Servo_GetByte(void) 
 635              {
 636   1              
 637   1          #if (UART_Servo_RX_INTERRUPT_ENABLED)
 638   1              uint16 locErrorStatus;
 639   1              /* Protect variables that could change on interrupt */
 640   1              UART_Servo_DisableRxInt();
 641   1              locErrorStatus = (uint16)UART_Servo_errorStatus;
 642   1              UART_Servo_errorStatus = 0u;
 643   1              UART_Servo_EnableRxInt();
 644   1              return ( (uint16)(locErrorStatus << 8u) | UART_Servo_ReadRxData() );
 645   1          #else
                      return ( ((uint16)UART_Servo_ReadRxStatus() << 8u) | UART_Servo_ReadRxData() );
                  #endif /* UART_Servo_RX_INTERRUPT_ENABLED */
 648   1              
 649   1          }
 650          
 651          
 652              /*******************************************************************************
 653              * Function Name: UART_Servo_GetRxBufferSize
 654              ********************************************************************************
 655              *
 656              * Summary:
 657              *  Returns the number of received bytes available in the RX buffer.
 658              *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
 659              *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
 660              *  * RX software buffer is enabled: returns the number of bytes available in 
 661              *    the RX software buffer. Bytes available in the RX FIFO do not take to 
 662              *    account.
 663              *
 664              * Parameters:
 665              *  None.
 666              *
 667              * Return:
 668              *  uint8: Number of bytes in the RX buffer. 
 669              *    Return value type depends on RX Buffer Size parameter.
 670              *
 671              * Global Variables:
 672              *  UART_Servo_rxBufferWrite - used to calculate left bytes.
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 12  

 673              *  UART_Servo_rxBufferRead - used to calculate left bytes.
 674              *  UART_Servo_rxBufferLoopDetect - checked to decide left bytes amount.
 675              *
 676              * Reentrant:
 677              *  No.
 678              *
 679              * Theory:
 680              *  Allows the user to find out how full the RX Buffer is.
 681              *
 682              *******************************************************************************/
 683              uint8 UART_Servo_GetRxBufferSize(void)
 684                                                                      
 685              {
 686   1              uint8 size;
 687   1      
 688   1          #if (UART_Servo_RX_INTERRUPT_ENABLED)
 689   1      
 690   1              /* Protect variables that could change on interrupt */
 691   1              UART_Servo_DisableRxInt();
 692   1      
 693   1              if(UART_Servo_rxBufferRead == UART_Servo_rxBufferWrite)
 694   1              {
 695   2                  if(UART_Servo_rxBufferLoopDetect != 0u)
 696   2                  {
 697   3                      size = UART_Servo_RX_BUFFER_SIZE;
 698   3                  }
 699   2                  else
 700   2                  {
 701   3                      size = 0u;
 702   3                  }
 703   2              }
 704   1              else if(UART_Servo_rxBufferRead < UART_Servo_rxBufferWrite)
 705   1              {
 706   2                  size = (UART_Servo_rxBufferWrite - UART_Servo_rxBufferRead);
 707   2              }
 708   1              else
 709   1              {
 710   2                  size = (UART_Servo_RX_BUFFER_SIZE - UART_Servo_rxBufferRead) + UART_Servo_rxBufferWrite;
 711   2              }
 712   1      
 713   1              UART_Servo_EnableRxInt();
 714   1      
 715   1          #else
              
                      /* We can only know if there is data in the fifo. */
                      size = ((UART_Servo_RXSTATUS_REG & UART_Servo_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
              
                  #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
 721   1      
 722   1              return(size);
 723   1          }
 724          
 725          
 726              /*******************************************************************************
 727              * Function Name: UART_Servo_ClearRxBuffer
 728              ********************************************************************************
 729              *
 730              * Summary:
 731              *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
 732              *
 733              * Parameters:
 734              *  None.
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 13  

 735              *
 736              * Return:
 737              *  None.
 738              *
 739              * Global Variables:
 740              *  UART_Servo_rxBufferWrite - cleared to zero.
 741              *  UART_Servo_rxBufferRead - cleared to zero.
 742              *  UART_Servo_rxBufferLoopDetect - cleared to zero.
 743              *  UART_Servo_rxBufferOverflow - cleared to zero.
 744              *
 745              * Reentrant:
 746              *  No.
 747              *
 748              * Theory:
 749              *  Setting the pointers to zero makes the system believe there is no data to
 750              *  read and writing will resume at address 0 overwriting any data that may
 751              *  have remained in the RAM.
 752              *
 753              * Side Effects:
 754              *  Any received data not read from the RAM or FIFO buffer will be lost.
 755              *
 756              *******************************************************************************/
 757              void UART_Servo_ClearRxBuffer(void) 
 758              {
 759   1              uint8 enableInterrupts;
 760   1      
 761   1              /* Clear the HW FIFO */
 762   1              enableInterrupts = CyEnterCriticalSection();
 763   1              UART_Servo_RXDATA_AUX_CTL_REG |= (uint8)  UART_Servo_RX_FIFO_CLR;
 764   1              UART_Servo_RXDATA_AUX_CTL_REG &= (uint8) ~UART_Servo_RX_FIFO_CLR;
 765   1              CyExitCriticalSection(enableInterrupts);
 766   1      
 767   1          #if (UART_Servo_RX_INTERRUPT_ENABLED)
 768   1      
 769   1              /* Protect variables that could change on interrupt. */
 770   1              UART_Servo_DisableRxInt();
 771   1      
 772   1              UART_Servo_rxBufferRead = 0u;
 773   1              UART_Servo_rxBufferWrite = 0u;
 774   1              UART_Servo_rxBufferLoopDetect = 0u;
 775   1              UART_Servo_rxBufferOverflow = 0u;
 776   1      
 777   1              UART_Servo_EnableRxInt();
 778   1      
 779   1          #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
 780   1      
 781   1          }
 782          
 783          
 784              /*******************************************************************************
 785              * Function Name: UART_Servo_SetRxAddressMode
 786              ********************************************************************************
 787              *
 788              * Summary:
 789              *  Sets the software controlled Addressing mode used by the RX portion of the
 790              *  UART.
 791              *
 792              * Parameters:
 793              *  addressMode: Enumerated value indicating the mode of RX addressing
 794              *  UART_Servo__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
 795              *                                               detection
 796              *  UART_Servo__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 14  

 797              *                                               address detection
 798              *  UART_Servo__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
 799              *                                               detection
 800              *  UART_Servo__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
 801              *                                               address detection
 802              *  UART_Servo__B_UART__AM_NONE - No address detection
 803              *
 804              * Return:
 805              *  None.
 806              *
 807              * Global Variables:
 808              *  UART_Servo_rxAddressMode - the parameter stored in this variable for
 809              *   the farther usage in RX ISR.
 810              *  UART_Servo_rxAddressDetected - set to initial state (0).
 811              *
 812              *******************************************************************************/
 813              void UART_Servo_SetRxAddressMode(uint8 addressMode)
 814                                                                  
 815              {
 816   1              #if(UART_Servo_RXHW_ADDRESS_ENABLED)
                          #if(UART_Servo_CONTROL_REG_REMOVED)
                              if(0u != addressMode)
                              {
                                  /* Suppress compiler warning */
                              }
                          #else /* UART_Servo_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = UART_Servo_CONTROL_REG & (uint8)~UART_Servo_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << UART_Servo_CTRL_RXADDR_MODE0_SHIFT);
                              UART_Servo_CONTROL_REG = tmpCtrl;
              
                              #if(UART_Servo_RX_INTERRUPT_ENABLED && \
                                 (UART_Servo_RXBUFFERSIZE > UART_Servo_FIFO_LENGTH) )
                                  UART_Servo_rxAddressMode = addressMode;
                                  UART_Servo_rxAddressDetected = 0u;
                              #endif /* End UART_Servo_RXBUFFERSIZE > UART_Servo_FIFO_LENGTH*/
                          #endif /* End UART_Servo_CONTROL_REG_REMOVED */
                      #else /* UART_Servo_RXHW_ADDRESS_ENABLED */
 835   1                  if(0u != addressMode)
 836   1                  {
 837   2                      /* Suppress compiler warning */
 838   2                  }
 839   1              #endif /* End UART_Servo_RXHW_ADDRESS_ENABLED */
 840   1          }
 841          
 842          
 843              /*******************************************************************************
 844              * Function Name: UART_Servo_SetRxAddress1
 845              ********************************************************************************
 846              *
 847              * Summary:
 848              *  Sets the first of two hardware-detectable receiver addresses.
 849              *
 850              * Parameters:
 851              *  address: Address #1 for hardware address detection.
 852              *
 853              * Return:
 854              *  None.
 855              *
 856              *******************************************************************************/
 857              void UART_Servo_SetRxAddress1(uint8 address) 
 858              {
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 15  

 859   1              UART_Servo_RXADDRESS1_REG = address;
 860   1          }
 861          
 862          
 863              /*******************************************************************************
 864              * Function Name: UART_Servo_SetRxAddress2
 865              ********************************************************************************
 866              *
 867              * Summary:
 868              *  Sets the second of two hardware-detectable receiver addresses.
 869              *
 870              * Parameters:
 871              *  address: Address #2 for hardware address detection.
 872              *
 873              * Return:
 874              *  None.
 875              *
 876              *******************************************************************************/
 877              void UART_Servo_SetRxAddress2(uint8 address) 
 878              {
 879   1              UART_Servo_RXADDRESS2_REG = address;
 880   1          }
 881          
 882          #endif  /* UART_Servo_RX_ENABLED || UART_Servo_HD_ENABLED*/
 883          
 884          
 885          #if( (UART_Servo_TX_ENABLED) || (UART_Servo_HD_ENABLED) )
 886              /*******************************************************************************
 887              * Function Name: UART_Servo_SetTxInterruptMode
 888              ********************************************************************************
 889              *
 890              * Summary:
 891              *  Configures the TX interrupt sources to be enabled, but does not enable the
 892              *  interrupt.
 893              *
 894              * Parameters:
 895              *  intSrc: Bit field containing the TX interrupt sources to enable
 896              *   UART_Servo_TX_STS_COMPLETE        Interrupt on TX byte complete
 897              *   UART_Servo_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898              *   UART_Servo_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899              *   UART_Servo_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900              *
 901              * Return:
 902              *  None.
 903              *
 904              * Theory:
 905              *  Enables the output of specific status bits to the interrupt controller
 906              *
 907              *******************************************************************************/
 908              void UART_Servo_SetTxInterruptMode(uint8 intSrc) 
 909              {
 910   1              UART_Servo_TXSTATUS_MASK_REG = intSrc;
 911   1          }
 912          
 913          
 914              /*******************************************************************************
 915              * Function Name: UART_Servo_WriteTxData
 916              ********************************************************************************
 917              *
 918              * Summary:
 919              *  Places a byte of data into the transmit buffer to be sent when the bus is
 920              *  available without checking the TX status register. You must check status
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 16  

 921              *  separately.
 922              *
 923              * Parameters:
 924              *  txDataByte: data byte
 925              *
 926              * Return:
 927              * None.
 928              *
 929              * Global Variables:
 930              *  UART_Servo_txBuffer - RAM buffer pointer for save data for transmission
 931              *  UART_Servo_txBufferWrite - cyclic index for write to txBuffer,
 932              *    incremented after each byte saved to buffer.
 933              *  UART_Servo_txBufferRead - cyclic index for read from txBuffer,
 934              *    checked to identify the condition to write to FIFO directly or to TX buffer
 935              *  UART_Servo_initVar - checked to identify that the component has been
 936              *    initialized.
 937              *
 938              * Reentrant:
 939              *  No.
 940              *
 941              *******************************************************************************/
 942              void UART_Servo_WriteTxData(uint8 txDataByte) 
 943              {
 944   1              /* If not Initialized then skip this function*/
 945   1              if(UART_Servo_initVar != 0u)
 946   1              {
 947   2              #if (UART_Servo_TX_INTERRUPT_ENABLED)
              
                          /* Protect variables that could change on interrupt. */
                          UART_Servo_DisableTxInt();
              
                          if( (UART_Servo_txBufferRead == UART_Servo_txBufferWrite) &&
                              ((UART_Servo_TXSTATUS_REG & UART_Servo_TX_STS_FIFO_FULL) == 0u) )
                          {
                              /* Add directly to the FIFO. */
                              UART_Servo_TXDATA_REG = txDataByte;
                          }
                          else
                          {
                              if(UART_Servo_txBufferWrite >= UART_Servo_TX_BUFFER_SIZE)
                              {
                                  UART_Servo_txBufferWrite = 0u;
                              }
              
                              UART_Servo_txBuffer[UART_Servo_txBufferWrite] = txDataByte;
              
                              /* Add to the software buffer. */
                              UART_Servo_txBufferWrite++;
                          }
              
                          UART_Servo_EnableTxInt();
              
                      #else
 974   2      
 975   2                  /* Add directly to the FIFO. */
 976   2                  UART_Servo_TXDATA_REG = txDataByte;
 977   2      
 978   2              #endif /*(UART_Servo_TX_INTERRUPT_ENABLED) */
 979   2              }
 980   1          }
 981          
 982          
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 17  

 983              /*******************************************************************************
 984              * Function Name: UART_Servo_ReadTxStatus
 985              ********************************************************************************
 986              *
 987              * Summary:
 988              *  Reads the status register for the TX portion of the UART.
 989              *
 990              * Parameters:
 991              *  None.
 992              *
 993              * Return:
 994              *  Contents of the status register
 995              *
 996              * Theory:
 997              *  This function reads the TX status register, which is cleared on read.
 998              *  It is up to the user to handle all bits in this return value accordingly,
 999              *  even if the bit was not enabled as an interrupt source the event happened
1000              *  and must be handled accordingly.
1001              *
1002              *******************************************************************************/
1003              uint8 UART_Servo_ReadTxStatus(void) 
1004              {
1005   1              return(UART_Servo_TXSTATUS_REG);
1006   1          }
1007          
1008          
1009              /*******************************************************************************
1010              * Function Name: UART_Servo_PutChar
1011              ********************************************************************************
1012              *
1013              * Summary:
1014              *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015              *  available. This is a blocking API that waits until the TX buffer has room to
1016              *  hold the data.
1017              *
1018              * Parameters:
1019              *  txDataByte: Byte containing the data to transmit
1020              *
1021              * Return:
1022              *  None.
1023              *
1024              * Global Variables:
1025              *  UART_Servo_txBuffer - RAM buffer pointer for save data for transmission
1026              *  UART_Servo_txBufferWrite - cyclic index for write to txBuffer,
1027              *     checked to identify free space in txBuffer and incremented after each byte
1028              *     saved to buffer.
1029              *  UART_Servo_txBufferRead - cyclic index for read from txBuffer,
1030              *     checked to identify free space in txBuffer.
1031              *  UART_Servo_initVar - checked to identify that the component has been
1032              *     initialized.
1033              *
1034              * Reentrant:
1035              *  No.
1036              *
1037              * Theory:
1038              *  Allows the user to transmit any byte of data in a single transfer
1039              *
1040              *******************************************************************************/
1041              void UART_Servo_PutChar(uint8 txDataByte) 
1042              {
1043   1          #if (UART_Servo_TX_INTERRUPT_ENABLED)
                      /* The temporary output pointer is used since it takes two instructions
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 18  

                      *  to increment with a wrap, and we can't risk doing that with the real
                      *  pointer and getting an interrupt in between instructions.
                      */
                      uint8 locTxBufferWrite;
                      uint8 locTxBufferRead;
              
                      do
                      { /* Block if software buffer is full, so we don't overwrite. */
              
                      #if ((UART_Servo_TX_BUFFER_SIZE > UART_Servo_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Disable TX interrupt to protect variables from modification */
                          UART_Servo_DisableTxInt();
                      #endif /* (UART_Servo_TX_BUFFER_SIZE > UART_Servo_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          locTxBufferWrite = UART_Servo_txBufferWrite;
                          locTxBufferRead  = UART_Servo_txBufferRead;
              
                      #if ((UART_Servo_TX_BUFFER_SIZE > UART_Servo_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Enable interrupt to continue transmission */
                          UART_Servo_EnableTxInt();
                      #endif /* (UART_Servo_TX_BUFFER_SIZE > UART_Servo_MAX_BYTE_VALUE) && (CY_PSOC3) */
                      }
                      while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) :
                                              ((locTxBufferWrite - locTxBufferRead) ==
                                              (uint8)(UART_Servo_TX_BUFFER_SIZE - 1u)) );
              
                      if( (locTxBufferRead == locTxBufferWrite) &&
                          ((UART_Servo_TXSTATUS_REG & UART_Servo_TX_STS_FIFO_FULL) == 0u) )
                      {
                          /* Add directly to the FIFO */
                          UART_Servo_TXDATA_REG = txDataByte;
                      }
                      else
                      {
                          if(locTxBufferWrite >= UART_Servo_TX_BUFFER_SIZE)
                          {
                              locTxBufferWrite = 0u;
                          }
                          /* Add to the software buffer. */
                          UART_Servo_txBuffer[locTxBufferWrite] = txDataByte;
                          locTxBufferWrite++;
              
                          /* Finally, update the real output pointer */
                      #if ((UART_Servo_TX_BUFFER_SIZE > UART_Servo_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_Servo_DisableTxInt();
                      #endif /* (UART_Servo_TX_BUFFER_SIZE > UART_Servo_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          UART_Servo_txBufferWrite = locTxBufferWrite;
              
                      #if ((UART_Servo_TX_BUFFER_SIZE > UART_Servo_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_Servo_EnableTxInt();
                      #endif /* (UART_Servo_TX_BUFFER_SIZE > UART_Servo_MAX_BYTE_VALUE) && (CY_PSOC3) */
              
                          if(0u != (UART_Servo_TXSTATUS_REG & UART_Servo_TX_STS_FIFO_EMPTY))
                          {
                              /* Trigger TX interrupt to send software buffer */
                              UART_Servo_SetPendingTxInt();
                          }
                      }
              
                  #else
1106   1      
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 19  

1107   1              while((UART_Servo_TXSTATUS_REG & UART_Servo_TX_STS_FIFO_FULL) != 0u)
1108   1              {
1109   2                  /* Wait for room in the FIFO */
1110   2              }
1111   1      
1112   1              /* Add directly to the FIFO */
1113   1              UART_Servo_TXDATA_REG = txDataByte;
1114   1      
1115   1          #endif /* UART_Servo_TX_INTERRUPT_ENABLED */
1116   1          }
1117          
1118          
1119              /*******************************************************************************
1120              * Function Name: UART_Servo_PutString
1121              ********************************************************************************
1122              *
1123              * Summary:
1124              *  Sends a NULL terminated string to the TX buffer for transmission.
1125              *
1126              * Parameters:
1127              *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128              *
1129              * Return:
1130              *  None.
1131              *
1132              * Global Variables:
1133              *  UART_Servo_initVar - checked to identify that the component has been
1134              *     initialized.
1135              *
1136              * Reentrant:
1137              *  No.
1138              *
1139              * Theory:
1140              *  If there is not enough memory in the TX buffer for the entire string, this
1141              *  function blocks until the last character of the string is loaded into the
1142              *  TX buffer.
1143              *
1144              *******************************************************************************/
1145              void UART_Servo_PutString(const char8 string[]) 
1146              {
1147   1              uint16 bufIndex = 0u;
1148   1      
1149   1              /* If not Initialized then skip this function */
1150   1              if(UART_Servo_initVar != 0u)
1151   1              {
1152   2                  /* This is a blocking function, it will not exit until all data is sent */
1153   2                  while(string[bufIndex] != (char8) 0)
1154   2                  {
1155   3                      UART_Servo_PutChar((uint8)string[bufIndex]);
1156   3                      bufIndex++;
1157   3                  }
1158   2              }
1159   1          }
1160          
1161          
1162              /*******************************************************************************
1163              * Function Name: UART_Servo_PutArray
1164              ********************************************************************************
1165              *
1166              * Summary:
1167              *  Places N bytes of data from a memory array into the TX buffer for
1168              *  transmission.
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 20  

1169              *
1170              * Parameters:
1171              *  string[]: Address of the memory array residing in RAM or ROM.
1172              *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173              *             Size parameter.
1174              *
1175              * Return:
1176              *  None.
1177              *
1178              * Global Variables:
1179              *  UART_Servo_initVar - checked to identify that the component has been
1180              *     initialized.
1181              *
1182              * Reentrant:
1183              *  No.
1184              *
1185              * Theory:
1186              *  If there is not enough memory in the TX buffer for the entire string, this
1187              *  function blocks until the last character of the string is loaded into the
1188              *  TX buffer.
1189              *
1190              *******************************************************************************/
1191              void UART_Servo_PutArray(const uint8 string[], uint8 byteCount)
1192                                                                              
1193              {
1194   1              uint8 bufIndex = 0u;
1195   1      
1196   1              /* If not Initialized then skip this function */
1197   1              if(UART_Servo_initVar != 0u)
1198   1              {
1199   2                  while(bufIndex < byteCount)
1200   2                  {
1201   3                      UART_Servo_PutChar(string[bufIndex]);
1202   3                      bufIndex++;
1203   3                  }
1204   2              }
1205   1          }
1206          
1207          
1208              /*******************************************************************************
1209              * Function Name: UART_Servo_PutCRLF
1210              ********************************************************************************
1211              *
1212              * Summary:
1213              *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214              *  (0x0A) to the transmit buffer.
1215              *
1216              * Parameters:
1217              *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218              *
1219              * Return:
1220              *  None.
1221              *
1222              * Global Variables:
1223              *  UART_Servo_initVar - checked to identify that the component has been
1224              *     initialized.
1225              *
1226              * Reentrant:
1227              *  No.
1228              *
1229              *******************************************************************************/
1230              void UART_Servo_PutCRLF(uint8 txDataByte) 
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 21  

1231              {
1232   1              /* If not Initialized then skip this function */
1233   1              if(UART_Servo_initVar != 0u)
1234   1              {
1235   2                  UART_Servo_PutChar(txDataByte);
1236   2                  UART_Servo_PutChar(0x0Du);
1237   2                  UART_Servo_PutChar(0x0Au);
1238   2              }
1239   1          }
1240          
1241          
1242              /*******************************************************************************
1243              * Function Name: UART_Servo_GetTxBufferSize
1244              ********************************************************************************
1245              *
1246              * Summary:
1247              *  Returns the number of bytes in the TX buffer which are waiting to be 
1248              *  transmitted.
1249              *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250              *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251              *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252              *    software buffer which are waiting to be transmitted. Bytes available in the
1253              *    TX FIFO do not count.
1254              *
1255              * Parameters:
1256              *  None.
1257              *
1258              * Return:
1259              *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260              *  Buffer Size parameter.
1261              *
1262              * Global Variables:
1263              *  UART_Servo_txBufferWrite - used to calculate left space.
1264              *  UART_Servo_txBufferRead - used to calculate left space.
1265              *
1266              * Reentrant:
1267              *  No.
1268              *
1269              * Theory:
1270              *  Allows the user to find out how full the TX Buffer is.
1271              *
1272              *******************************************************************************/
1273              uint8 UART_Servo_GetTxBufferSize(void)
1274                                                                      
1275              {
1276   1              uint8 size;
1277   1      
1278   1          #if (UART_Servo_TX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_Servo_DisableTxInt();
              
                      if(UART_Servo_txBufferRead == UART_Servo_txBufferWrite)
                      {
                          size = 0u;
                      }
                      else if(UART_Servo_txBufferRead < UART_Servo_txBufferWrite)
                      {
                          size = (UART_Servo_txBufferWrite - UART_Servo_txBufferRead);
                      }
                      else
                      {
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 22  

                          size = (UART_Servo_TX_BUFFER_SIZE - UART_Servo_txBufferRead) +
                                  UART_Servo_txBufferWrite;
                      }
              
                      UART_Servo_EnableTxInt();
              
                  #else
1300   1      
1301   1              size = UART_Servo_TXSTATUS_REG;
1302   1      
1303   1              /* Is the fifo is full. */
1304   1              if((size & UART_Servo_TX_STS_FIFO_FULL) != 0u)
1305   1              {
1306   2                  size = UART_Servo_FIFO_LENGTH;
1307   2              }
1308   1              else if((size & UART_Servo_TX_STS_FIFO_EMPTY) != 0u)
1309   1              {
1310   2                  size = 0u;
1311   2              }
1312   1              else
1313   1              {
1314   2                  /* We only know there is data in the fifo. */
1315   2                  size = 1u;
1316   2              }
1317   1      
1318   1          #endif /* (UART_Servo_TX_INTERRUPT_ENABLED) */
1319   1      
1320   1          return(size);
1321   1          }
1322          
1323          
1324              /*******************************************************************************
1325              * Function Name: UART_Servo_ClearTxBuffer
1326              ********************************************************************************
1327              *
1328              * Summary:
1329              *  Clears all data from the TX buffer and hardware TX FIFO.
1330              *
1331              * Parameters:
1332              *  None.
1333              *
1334              * Return:
1335              *  None.
1336              *
1337              * Global Variables:
1338              *  UART_Servo_txBufferWrite - cleared to zero.
1339              *  UART_Servo_txBufferRead - cleared to zero.
1340              *
1341              * Reentrant:
1342              *  No.
1343              *
1344              * Theory:
1345              *  Setting the pointers to zero makes the system believe there is no data to
1346              *  read and writing will resume at address 0 overwriting any data that may have
1347              *  remained in the RAM.
1348              *
1349              * Side Effects:
1350              *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351              *  transmitting finishes transmitting.
1352              *
1353              *******************************************************************************/
1354              void UART_Servo_ClearTxBuffer(void) 
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 23  

1355              {
1356   1              uint8 enableInterrupts;
1357   1      
1358   1              enableInterrupts = CyEnterCriticalSection();
1359   1              /* Clear the HW FIFO */
1360   1              UART_Servo_TXDATA_AUX_CTL_REG |= (uint8)  UART_Servo_TX_FIFO_CLR;
1361   1              UART_Servo_TXDATA_AUX_CTL_REG &= (uint8) ~UART_Servo_TX_FIFO_CLR;
1362   1              CyExitCriticalSection(enableInterrupts);
1363   1      
1364   1          #if (UART_Servo_TX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_Servo_DisableTxInt();
              
                      UART_Servo_txBufferRead = 0u;
                      UART_Servo_txBufferWrite = 0u;
              
                      /* Enable Tx interrupt. */
                      UART_Servo_EnableTxInt();
              
                  #endif /* (UART_Servo_TX_INTERRUPT_ENABLED) */
1376   1          }
1377          
1378          
1379              /*******************************************************************************
1380              * Function Name: UART_Servo_SendBreak
1381              ********************************************************************************
1382              *
1383              * Summary:
1384              *  Transmits a break signal on the bus.
1385              *
1386              * Parameters:
1387              *  uint8 retMode:  Send Break return mode. See the following table for options.
1388              *   UART_Servo_SEND_BREAK - Initialize registers for break, send the Break
1389              *       signal and return immediately.
1390              *   UART_Servo_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391              *       complete, reinitialize registers to normal transmission mode then return
1392              *   UART_Servo_REINIT - Reinitialize registers to normal transmission mode
1393              *       then return.
1394              *   UART_Servo_SEND_WAIT_REINIT - Performs both options: 
1395              *      UART_Servo_SEND_BREAK and UART_Servo_WAIT_FOR_COMPLETE_REINIT.
1396              *      This option is recommended for most cases.
1397              *
1398              * Return:
1399              *  None.
1400              *
1401              * Global Variables:
1402              *  UART_Servo_initVar - checked to identify that the component has been
1403              *     initialized.
1404              *  txPeriod - static variable, used for keeping TX period configuration.
1405              *
1406              * Reentrant:
1407              *  No.
1408              *
1409              * Theory:
1410              *  SendBreak function initializes registers to send 13-bit break signal. It is
1411              *  important to return the registers configuration to normal for continue 8-bit
1412              *  operation.
1413              *  There are 3 variants for this API usage:
1414              *  1) SendBreak(3) - function will send the Break signal and take care on the
1415              *     configuration returning. Function will block CPU until transmission
1416              *     complete.
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 24  

1417              *  2) User may want to use blocking time if UART configured to the low speed
1418              *     operation
1419              *     Example for this case:
1420              *     SendBreak(0);     - initialize Break signal transmission
1421              *         Add your code here to use CPU time
1422              *     SendBreak(1);     - complete Break operation
1423              *  3) Same to 2) but user may want to initialize and use the interrupt to
1424              *     complete break operation.
1425              *     Example for this case:
1426              *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427              *     SendBreak(0);     - initialize Break signal transmission
1428              *         Add your code here to use CPU time
1429              *     When interrupt appear with UART_Servo_TX_STS_COMPLETE status:
1430              *     SendBreak(2);     - complete Break operation
1431              *
1432              * Side Effects:
1433              *  The UART_Servo_SendBreak() function initializes registers to send a
1434              *  break signal.
1435              *  Break signal length depends on the break signal bits configuration.
1436              *  The register configuration should be reinitialized before normal 8-bit
1437              *  communication can continue.
1438              *
1439              *******************************************************************************/
1440              void UART_Servo_SendBreak(uint8 retMode) 
1441              {
1442   1      
1443   1              /* If not Initialized then skip this function*/
1444   1              if(UART_Servo_initVar != 0u)
1445   1              {
1446   2                  /* Set the Counter to 13-bits and transmit a 00 byte */
1447   2                  /* When that is done then reset the counter value back */
1448   2                  uint8 tmpStat;
1449   2      
1450   2              #if(UART_Servo_HD_ENABLED) /* Half Duplex mode*/
              
                          if( (retMode == UART_Servo_SEND_BREAK) ||
                              (retMode == UART_Servo_SEND_WAIT_REINIT ) )
                          {
                              /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
                              UART_Servo_WriteControlRegister(UART_Servo_ReadControlRegister() |
                                                                    UART_Servo_CTRL_HD_SEND_BREAK);
                              /* Send zeros */
                              UART_Servo_TXDATA_REG = 0u;
              
                              do /* Wait until transmit starts */
                              {
                                  tmpStat = UART_Servo_TXSTATUS_REG;
                              }
                              while((tmpStat & UART_Servo_TX_STS_FIFO_EMPTY) != 0u);
                          }
              
                          if( (retMode == UART_Servo_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_Servo_SEND_WAIT_REINIT) )
                          {
                              do /* Wait until transmit complete */
                              {
                                  tmpStat = UART_Servo_TXSTATUS_REG;
                              }
                              while(((uint8)~tmpStat & UART_Servo_TX_STS_COMPLETE) != 0u);
                          }
              
                          if( (retMode == UART_Servo_WAIT_FOR_COMPLETE_REINIT) ||
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 25  

                              (retMode == UART_Servo_REINIT) ||
                              (retMode == UART_Servo_SEND_WAIT_REINIT) )
                          {
                              UART_Servo_WriteControlRegister(UART_Servo_ReadControlRegister() &
                                                            (uint8)~UART_Servo_CTRL_HD_SEND_BREAK);
                          }
              
                      #else /* UART_Servo_HD_ENABLED Full Duplex mode */
1487   2      
1488   2                  static uint8 txPeriod;
1489   2      
1490   2                  if( (retMode == UART_Servo_SEND_BREAK) ||
1491   2                      (retMode == UART_Servo_SEND_WAIT_REINIT) )
1492   2                  {
1493   3                      /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode */
1494   3                      #if( (UART_Servo_PARITY_TYPE != UART_Servo__B_UART__NONE_REVB) || \
1495   3                                          (UART_Servo_PARITY_TYPE_SW != 0u) )
1496   3                          UART_Servo_WriteControlRegister(UART_Servo_ReadControlRegister() |
1497   3                                                                UART_Servo_CTRL_HD_SEND_BREAK);
1498   3                      #endif /* End UART_Servo_PARITY_TYPE != UART_Servo__B_UART__NONE_REVB  */
1499   3      
1500   3                      #if(UART_Servo_TXCLKGEN_DP)
1501   3                          txPeriod = UART_Servo_TXBITCLKTX_COMPLETE_REG;
1502   3                          UART_Servo_TXBITCLKTX_COMPLETE_REG = UART_Servo_TXBITCTR_BREAKBITS;
1503   3                      #else
                                  txPeriod = UART_Servo_TXBITCTR_PERIOD_REG;
                                  UART_Servo_TXBITCTR_PERIOD_REG = UART_Servo_TXBITCTR_BREAKBITS8X;
                              #endif /* End UART_Servo_TXCLKGEN_DP */
1507   3      
1508   3                      /* Send zeros */
1509   3                      UART_Servo_TXDATA_REG = 0u;
1510   3      
1511   3                      do /* Wait until transmit starts */
1512   3                      {
1513   4                          tmpStat = UART_Servo_TXSTATUS_REG;
1514   4                      }
1515   3                      while((tmpStat & UART_Servo_TX_STS_FIFO_EMPTY) != 0u);
1516   3                  }
1517   2      
1518   2                  if( (retMode == UART_Servo_WAIT_FOR_COMPLETE_REINIT) ||
1519   2                      (retMode == UART_Servo_SEND_WAIT_REINIT) )
1520   2                  {
1521   3                      do /* Wait until transmit complete */
1522   3                      {
1523   4                          tmpStat = UART_Servo_TXSTATUS_REG;
1524   4                      }
1525   3                      while(((uint8)~tmpStat & UART_Servo_TX_STS_COMPLETE) != 0u);
1526   3                  }
1527   2      
1528   2                  if( (retMode == UART_Servo_WAIT_FOR_COMPLETE_REINIT) ||
1529   2                      (retMode == UART_Servo_REINIT) ||
1530   2                      (retMode == UART_Servo_SEND_WAIT_REINIT) )
1531   2                  {
1532   3      
1533   3                  #if(UART_Servo_TXCLKGEN_DP)
1534   3                      UART_Servo_TXBITCLKTX_COMPLETE_REG = txPeriod;
1535   3                  #else
                              UART_Servo_TXBITCTR_PERIOD_REG = txPeriod;
                          #endif /* End UART_Servo_TXCLKGEN_DP */
1538   3      
1539   3                  #if( (UART_Servo_PARITY_TYPE != UART_Servo__B_UART__NONE_REVB) || \
1540   3                       (UART_Servo_PARITY_TYPE_SW != 0u) )
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 26  

1541   3                      UART_Servo_WriteControlRegister(UART_Servo_ReadControlRegister() &
1542   3                                                            (uint8) ~UART_Servo_CTRL_HD_SEND_BREAK);
1543   3                  #endif /* End UART_Servo_PARITY_TYPE != NONE */
1544   3                  }
1545   2              #endif    /* End UART_Servo_HD_ENABLED */
1546   2              }
1547   1          }
1548          
1549          
1550              /*******************************************************************************
1551              * Function Name: UART_Servo_SetTxAddressMode
1552              ********************************************************************************
1553              *
1554              * Summary:
1555              *  Configures the transmitter to signal the next bytes is address or data.
1556              *
1557              * Parameters:
1558              *  addressMode: 
1559              *       UART_Servo_SET_SPACE - Configure the transmitter to send the next
1560              *                                    byte as a data.
1561              *       UART_Servo_SET_MARK  - Configure the transmitter to send the next
1562              *                                    byte as an address.
1563              *
1564              * Return:
1565              *  None.
1566              *
1567              * Side Effects:
1568              *  This function sets and clears UART_Servo_CTRL_MARK bit in the Control
1569              *  register.
1570              *
1571              *******************************************************************************/
1572              void UART_Servo_SetTxAddressMode(uint8 addressMode) 
1573              {
1574   1              /* Mark/Space sending enable */
1575   1              if(addressMode != 0u)
1576   1              {
1577   2              #if( UART_Servo_CONTROL_REG_REMOVED == 0u )
                          UART_Servo_WriteControlRegister(UART_Servo_ReadControlRegister() |
                                                                UART_Servo_CTRL_MARK);
                      #endif /* End UART_Servo_CONTROL_REG_REMOVED == 0u */
1581   2              }
1582   1              else
1583   1              {
1584   2              #if( UART_Servo_CONTROL_REG_REMOVED == 0u )
                          UART_Servo_WriteControlRegister(UART_Servo_ReadControlRegister() &
                                                                (uint8) ~UART_Servo_CTRL_MARK);
                      #endif /* End UART_Servo_CONTROL_REG_REMOVED == 0u */
1588   2              }
1589   1          }
1590          
1591          #endif  /* EndUART_Servo_TX_ENABLED */
1592          
1593          #if(UART_Servo_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_Servo_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the receiver configuration in half duplex mode. After calling this
                  *  function, the UART is ready to receive data.
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 27  

                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the transmitter
                  *  configuration.
                  *
                  *******************************************************************************/
                  void UART_Servo_LoadRxConfig(void) 
                  {
                      UART_Servo_WriteControlRegister(UART_Servo_ReadControlRegister() &
                                                              (uint8)~UART_Servo_CTRL_HD_SEND);
                      UART_Servo_RXBITCTR_PERIOD_REG = UART_Servo_HD_RXBITCTR_INIT;
              
                  #if (UART_Servo_RX_INTERRUPT_ENABLED)
                      /* Enable RX interrupt after set RX configuration */
                      UART_Servo_SetRxInterruptMode(UART_Servo_INIT_RX_INTERRUPTS_MASK);
                  #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Servo_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the transmitter configuration in half duplex mode. After calling this
                  *  function, the UART is ready to transmit data.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the receiver configuration.
                  *
                  *******************************************************************************/
                  void UART_Servo_LoadTxConfig(void) 
                  {
                  #if (UART_Servo_RX_INTERRUPT_ENABLED)
                      /* Disable RX interrupts before set TX configuration */
                      UART_Servo_SetRxInterruptMode(0u);
                  #endif /* (UART_Servo_RX_INTERRUPT_ENABLED) */
              
                      UART_Servo_WriteControlRegister(UART_Servo_ReadControlRegister() | UART_Servo_CTRL_HD_SEND);
                      UART_Servo_RXBITCTR_PERIOD_REG = UART_Servo_HD_TXBITCTR_INIT;
                  }
              
              #endif  /* UART_Servo_HD_ENABLED */
1660          
1661          
1662          /* [] END OF FILE */
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 28  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_Servo_Start (BEGIN)
                                           ; SOURCE LINE # 76
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 79
0000 900000      R     MOV     DPTR,#UART_Servo_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 80
                                           ; SOURCE LINE # 81
0008 120000      R     LCALL   UART_Servo_Init
                                           ; SOURCE LINE # 82
000B 900000      R     MOV     DPTR,#UART_Servo_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 83
0011         ?C0001:
                                           ; SOURCE LINE # 85
0011 120000      R     LCALL   UART_Servo_Enable
                                           ; SOURCE LINE # 86
0014 22                RET     
             ; FUNCTION UART_Servo_Start (END)

             ; FUNCTION UART_Servo_Init (BEGIN)
                                           ; SOURCE LINE # 106
                                           ; SOURCE LINE # 107
                                           ; SOURCE LINE # 112
0000 7C00        E     MOV     R4,#HIGH UART_Servo_RXISR
0002 7D00        E     MOV     R5,#LOW UART_Servo_RXISR
0004 7F02              MOV     R7,#02H
0006 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 113
0009 7D07              MOV     R5,#07H
000B 7F02              MOV     R7,#02H
000D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 114
0010 900000      R     MOV     DPTR,#UART_Servo_errorStatus
0013 E4                CLR     A
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 124
0015 906481            MOV     DPTR,#06481H
0018 7472              MOV     A,#072H
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
001B 906482            MOV     DPTR,#06482H
001E 7420              MOV     A,#020H
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 138
0021 906423            MOV     DPTR,#06423H
0024 7406              MOV     A,#06H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
0027 906433            MOV     DPTR,#06433H
002A 7447              MOV     A,#047H
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 150
002D 906484            MOV     DPTR,#06484H
0030 E4                CLR     A
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 29  

0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
0032 22                RET     
             ; FUNCTION UART_Servo_Init (END)

             ; FUNCTION UART_Servo_Enable (BEGIN)
                                           ; SOURCE LINE # 183
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 186
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 190
0008 906491            MOV     DPTR,#06491H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4420              ORL     A,#020H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 193
0013 906492            MOV     DPTR,#06492H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4410              ORL     A,#010H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 196
001E 9044C0            MOV     DPTR,#044C0H
0021 7404              MOV     A,#04H
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 211
0024 906494            MOV     DPTR,#06494H
0027 E0                MOVX    A,@DPTR
0028 FF                MOV     R7,A
0029 EF                MOV     A,R7
002A 4410              ORL     A,#010H
002C FF                MOV     R7,A
002D EF                MOV     A,R7
002E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 219
002F 120000      E     LCALL   UART_Servo_IntClock_Start
                                           ; SOURCE LINE # 222
0032 900000      R     MOV     DPTR,#enableInterrupts
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 223
003A 22                RET     
             ; FUNCTION UART_Servo_Enable (END)

             ; FUNCTION UART_Servo_Stop (BEGIN)
                                           ; SOURCE LINE # 240
                                           ; SOURCE LINE # 241
                                           ; SOURCE LINE # 243
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 30  

0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 247
0008 906491            MOV     DPTR,#06491H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54DF              ANL     A,#0DFH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 257
0013 120000      E     LCALL   UART_Servo_IntClock_Stop
                                           ; SOURCE LINE # 262
0016 906492            MOV     DPTR,#06492H
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C 54EF              ANL     A,#0EFH
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 265
0021 9044C8            MOV     DPTR,#044C8H
0024 7404              MOV     A,#04H
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 270
0027 906494            MOV     DPTR,#06494H
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 54EF              ANL     A,#0EFH
002F FF                MOV     R7,A
0030 EF                MOV     A,R7
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
0032 900000      R     MOV     DPTR,#enableInterrupts
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 278
003A 22                RET     
             ; FUNCTION UART_Servo_Stop (END)

             ; FUNCTION UART_Servo_ReadControlRegister (BEGIN)
                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 298
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 302
0002         ?C0006:
0002 22                RET     
             ; FUNCTION UART_Servo_ReadControlRegister (END)

             ; FUNCTION _UART_Servo_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 319
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 322
                                           ; SOURCE LINE # 323
                                           ; SOURCE LINE # 325
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 31  

                                           ; SOURCE LINE # 329
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _UART_Servo_WriteControlRegister (END)

             ; FUNCTION _UART_Servo_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 359
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 360
                                           ; SOURCE LINE # 361
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906482            MOV     DPTR,#06482H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 362
000F 22                RET     
             ; FUNCTION _UART_Servo_SetRxInterruptMode (END)

             ; FUNCTION UART_Servo_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 392
                                           ; SOURCE LINE # 393
                                           ; SOURCE LINE # 402
0000 9044C8            MOV     DPTR,#044C8H
0003 7404              MOV     A,#04H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 404
0006 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B 900000      R     MOV     DPTR,#locRxBufferRead
000E EF                MOV     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 405
0010 900000      R     MOV     DPTR,#UART_Servo_rxBufferWrite
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 900000      R     MOV     DPTR,#locRxBufferWrite
0018 EF                MOV     A,R7
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 407
001A 900000      R     MOV     DPTR,#UART_Servo_rxBufferLoopDetect
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 700E              JNZ     ?C0011
0022 900000      R     MOV     DPTR,#locRxBufferWrite
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#locRxBufferRead
002A E0                MOVX    A,@DPTR
002B FE                MOV     R6,A
002C EE                MOV     A,R6
002D 6F                XRL     A,R7
002E 6045              JZ      ?C0010
0030         ?C0011:
                                           ; SOURCE LINE # 408
                                           ; SOURCE LINE # 409
0030 900000      R     MOV     DPTR,#locRxBufferRead
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 32  

0033 E0                MOVX    A,@DPTR
0034 FF                MOV     R7,A
0035 7400        R     MOV     A,#LOW UART_Servo_rxBuffer
0037 2F                ADD     A,R7
0038 F582              MOV     DPL,A
003A E4                CLR     A
003B 3400        R     ADDC    A,#HIGH UART_Servo_rxBuffer
003D F583              MOV     DPH,A
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 900000      R     MOV     DPTR,#rxData
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 410
0046 900000      R     MOV     DPTR,#locRxBufferRead
0049 E0                MOVX    A,@DPTR
004A 04                INC     A
004B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 412
004C 900000      R     MOV     DPTR,#locRxBufferRead
004F E0                MOVX    A,@DPTR
0050 FF                MOV     R7,A
0051 EF                MOV     A,R7
0052 C3                CLR     C
0053 94FF              SUBB    A,#0FFH
0055 4005              JC      ?C0012
                                           ; SOURCE LINE # 413
                                           ; SOURCE LINE # 414
0057 900000      R     MOV     DPTR,#locRxBufferRead
005A E4                CLR     A
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 415
005C         ?C0012:
                                           ; SOURCE LINE # 417
005C 900000      R     MOV     DPTR,#locRxBufferRead
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
0061 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
0064 EF                MOV     A,R7
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 419
0066 900000      R     MOV     DPTR,#UART_Servo_rxBufferLoopDetect
0069 E0                MOVX    A,@DPTR
006A FF                MOV     R7,A
006B EF                MOV     A,R7
006C 6011              JZ      ?C0014
                                           ; SOURCE LINE # 420
                                           ; SOURCE LINE # 421
006E 900000      R     MOV     DPTR,#UART_Servo_rxBufferLoopDetect
0071 E4                CLR     A
0072 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 436
                                           ; SOURCE LINE # 437
0073 800A              SJMP    ?C0014
0075         ?C0010:
                                           ; SOURCE LINE # 439
                                           ; SOURCE LINE # 440
0075 906441            MOV     DPTR,#06441H
0078 E0                MOVX    A,@DPTR
0079 FF                MOV     R7,A
007A 900000      R     MOV     DPTR,#rxData
007D EF                MOV     A,R7
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 33  

007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 441
007F         ?C0014:
                                           ; SOURCE LINE # 443
007F 9044C0            MOV     DPTR,#044C0H
0082 7404              MOV     A,#04H
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 452
0085 900000      R     MOV     DPTR,#rxData
0088 E0                MOVX    A,@DPTR
0089 FF                MOV     R7,A
                                           ; SOURCE LINE # 453
008A         ?C0015:
008A 22                RET     
             ; FUNCTION UART_Servo_ReadRxData (END)

             ; FUNCTION UART_Servo_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 485
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 489
0000 906462            MOV     DPTR,#06462H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 547F              ANL     A,#07FH
0008 FF                MOV     R7,A
0009 900000      R     MOV     DPTR,#status
000C EF                MOV     A,R7
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 492
000E 900000      R     MOV     DPTR,#UART_Servo_rxBufferOverflow
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 6013              JZ      ?C0016
                                           ; SOURCE LINE # 493
                                           ; SOURCE LINE # 494
0016 900000      R     MOV     DPTR,#status
0019 E0                MOVX    A,@DPTR
001A FF                MOV     R7,A
001B EF                MOV     A,R7
001C 4480              ORL     A,#080H
001E FF                MOV     R7,A
001F 900000      R     MOV     DPTR,#status
0022 EF                MOV     A,R7
0023 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 495
0024 900000      R     MOV     DPTR,#UART_Servo_rxBufferOverflow
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 496
0029         ?C0016:
                                           ; SOURCE LINE # 499
0029 900000      R     MOV     DPTR,#status
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
                                           ; SOURCE LINE # 500
002E         ?C0017:
002E 22                RET     
             ; FUNCTION UART_Servo_ReadRxStatus (END)

             ; FUNCTION UART_Servo_GetChar (BEGIN)
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 34  

                                           ; SOURCE LINE # 532
                                           ; SOURCE LINE # 533
                                           ; SOURCE LINE # 534
0000 900000      R     MOV     DPTR,#rxData
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 542
0005 9044C8            MOV     DPTR,#044C8H
0008 7404              MOV     A,#04H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 544
000B 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 900000      R     MOV     DPTR,#locRxBufferRead
0013 EF                MOV     A,R7
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 545
0015 900000      R     MOV     DPTR,#UART_Servo_rxBufferWrite
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A 900000      R     MOV     DPTR,#locRxBufferWrite
001D EF                MOV     A,R7
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 547
001F 900000      R     MOV     DPTR,#UART_Servo_rxBufferLoopDetect
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 EF                MOV     A,R7
0025 700E              JNZ     ?C0019
0027 900000      R     MOV     DPTR,#locRxBufferWrite
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C 900000      R     MOV     DPTR,#locRxBufferRead
002F E0                MOVX    A,@DPTR
0030 FE                MOV     R6,A
0031 EE                MOV     A,R6
0032 6F                XRL     A,R7
0033 6045              JZ      ?C0018
0035         ?C0019:
                                           ; SOURCE LINE # 548
                                           ; SOURCE LINE # 549
0035 900000      R     MOV     DPTR,#locRxBufferRead
0038 E0                MOVX    A,@DPTR
0039 FF                MOV     R7,A
003A 7400        R     MOV     A,#LOW UART_Servo_rxBuffer
003C 2F                ADD     A,R7
003D F582              MOV     DPL,A
003F E4                CLR     A
0040 3400        R     ADDC    A,#HIGH UART_Servo_rxBuffer
0042 F583              MOV     DPH,A
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 900000      R     MOV     DPTR,#rxData
0049 EF                MOV     A,R7
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 550
004B 900000      R     MOV     DPTR,#locRxBufferRead
004E E0                MOVX    A,@DPTR
004F 04                INC     A
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 551
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 35  

0051 900000      R     MOV     DPTR,#locRxBufferRead
0054 E0                MOVX    A,@DPTR
0055 FF                MOV     R7,A
0056 EF                MOV     A,R7
0057 C3                CLR     C
0058 94FF              SUBB    A,#0FFH
005A 4005              JC      ?C0020
                                           ; SOURCE LINE # 552
                                           ; SOURCE LINE # 553
005C 900000      R     MOV     DPTR,#locRxBufferRead
005F E4                CLR     A
0060 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 554
0061         ?C0020:
                                           ; SOURCE LINE # 556
0061 900000      R     MOV     DPTR,#locRxBufferRead
0064 E0                MOVX    A,@DPTR
0065 FF                MOV     R7,A
0066 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
0069 EF                MOV     A,R7
006A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 558
006B 900000      R     MOV     DPTR,#UART_Servo_rxBufferLoopDetect
006E E0                MOVX    A,@DPTR
006F FF                MOV     R7,A
0070 EF                MOV     A,R7
0071 6038              JZ      ?C0022
                                           ; SOURCE LINE # 559
                                           ; SOURCE LINE # 560
0073 900000      R     MOV     DPTR,#UART_Servo_rxBufferLoopDetect
0076 E4                CLR     A
0077 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 575
                                           ; SOURCE LINE # 577
0078 8031              SJMP    ?C0022
007A         ?C0018:
                                           ; SOURCE LINE # 579
007A 906462            MOV     DPTR,#06462H
007D E0                MOVX    A,@DPTR
007E FF                MOV     R7,A
007F 900000      R     MOV     DPTR,#rxStatus
0082 EF                MOV     A,R7
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 580
0084 900000      R     MOV     DPTR,#rxStatus
0087 E0                MOVX    A,@DPTR
0088 FF                MOV     R7,A
0089 EF                MOV     A,R7
008A 30E51E            JNB     ACC.5,?C0022
                                           ; SOURCE LINE # 581
                                           ; SOURCE LINE # 582
008D 906441            MOV     DPTR,#06441H
0090 E0                MOVX    A,@DPTR
0091 FF                MOV     R7,A
0092 900000      R     MOV     DPTR,#rxData
0095 EF                MOV     A,R7
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 585
0097 900000      R     MOV     DPTR,#rxStatus
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C EF                MOV     A,R7
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 36  

009D 541E              ANL     A,#01EH
009F FF                MOV     R7,A
00A0 7E00              MOV     R6,#00H
00A2 EF                MOV     A,R7
00A3 4E                ORL     A,R6
00A4 6005              JZ      ?C0022
                                           ; SOURCE LINE # 586
                                           ; SOURCE LINE # 587
00A6 900000      R     MOV     DPTR,#rxData
00A9 E4                CLR     A
00AA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 588
                                           ; SOURCE LINE # 589
                                           ; SOURCE LINE # 590
00AB         ?C0022:
                                           ; SOURCE LINE # 592
00AB 9044C0            MOV     DPTR,#044C0H
00AE 7404              MOV     A,#04H
00B0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 611
00B1 900000      R     MOV     DPTR,#rxData
00B4 E0                MOVX    A,@DPTR
00B5 FF                MOV     R7,A
                                           ; SOURCE LINE # 612
00B6         ?C0025:
00B6 22                RET     
             ; FUNCTION UART_Servo_GetChar (END)

             ; FUNCTION UART_Servo_GetByte (BEGIN)
                                           ; SOURCE LINE # 634
                                           ; SOURCE LINE # 635
                                           ; SOURCE LINE # 640
0000 9044C8            MOV     DPTR,#044C8H
0003 7404              MOV     A,#04H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 641
0006 900000      R     MOV     DPTR,#UART_Servo_errorStatus
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B 7E00              MOV     R6,#00H
000D 900000      R     MOV     DPTR,#locErrorStatus
0010 EE                MOV     A,R6
0011 F0                MOVX    @DPTR,A
0012 A3                INC     DPTR
0013 EF                MOV     A,R7
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 642
0015 900000      R     MOV     DPTR,#UART_Servo_errorStatus
0018 E4                CLR     A
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 643
001A 9044C0            MOV     DPTR,#044C0H
001D 7404              MOV     A,#04H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 644
0020 120000      R     LCALL   UART_Servo_ReadRxData
0023 EF                MOV     A,R7
0024 FD                MOV     R5,A
0025 7C00              MOV     R4,#00H
0027 900000      R     MOV     DPTR,#locErrorStatus
002A E0                MOVX    A,@DPTR
002B FE                MOV     R6,A
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 37  

002C A3                INC     DPTR
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F EF                MOV     A,R7
0030 7F00              MOV     R7,#00H
0032 FE                MOV     R6,A
0033 EE                MOV     A,R6
0034 4C                ORL     A,R4
0035 FE                MOV     R6,A
0036 EF                MOV     A,R7
0037 4D                ORL     A,R5
0038 FF                MOV     R7,A
                                           ; SOURCE LINE # 649
0039         ?C0026:
0039 22                RET     
             ; FUNCTION UART_Servo_GetByte (END)

             ; FUNCTION UART_Servo_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 683
                                           ; SOURCE LINE # 685
                                           ; SOURCE LINE # 691
0000 9044C8            MOV     DPTR,#044C8H
0003 7404              MOV     A,#04H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 693
0006 900000      R     MOV     DPTR,#UART_Servo_rxBufferWrite
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
000E E0                MOVX    A,@DPTR
000F FE                MOV     R6,A
0010 EE                MOV     A,R6
0011 B50717            CJNE    A,AR7,?C0027
                                           ; SOURCE LINE # 694
                                           ; SOURCE LINE # 695
0014 900000      R     MOV     DPTR,#UART_Servo_rxBufferLoopDetect
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
0019 EF                MOV     A,R7
001A 6008              JZ      ?C0028
                                           ; SOURCE LINE # 696
                                           ; SOURCE LINE # 697
001C 900000      R     MOV     DPTR,#size
001F 74FF              MOV     A,#0FFH
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 698
0022 8042              SJMP    ?C0030
0024         ?C0028:
                                           ; SOURCE LINE # 700
                                           ; SOURCE LINE # 701
0024 900000      R     MOV     DPTR,#size
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 702
                                           ; SOURCE LINE # 703
0029 803B              SJMP    ?C0030
002B         ?C0027:
                                           ; SOURCE LINE # 704
002B 900000      R     MOV     DPTR,#UART_Servo_rxBufferWrite
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
0030 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 38  

0033 E0                MOVX    A,@DPTR
0034 FE                MOV     R6,A
0035 EE                MOV     A,R6
0036 C3                CLR     C
0037 9F                SUBB    A,R7
0038 5015              JNC     ?C0031
                                           ; SOURCE LINE # 705
                                           ; SOURCE LINE # 706
003A 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F 900000      R     MOV     DPTR,#UART_Servo_rxBufferWrite
0042 E0                MOVX    A,@DPTR
0043 FE                MOV     R6,A
0044 C3                CLR     C
0045 EE                MOV     A,R6
0046 9F                SUBB    A,R7
0047 FF                MOV     R7,A
0048 900000      R     MOV     DPTR,#size
004B EF                MOV     A,R7
004C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 707
004D 8017              SJMP    ?C0030
004F         ?C0031:
                                           ; SOURCE LINE # 709
                                           ; SOURCE LINE # 710
004F 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
0052 E0                MOVX    A,@DPTR
0053 FF                MOV     R7,A
0054 C3                CLR     C
0055 74FF              MOV     A,#0FFH
0057 9F                SUBB    A,R7
0058 FF                MOV     R7,A
0059 900000      R     MOV     DPTR,#UART_Servo_rxBufferWrite
005C E0                MOVX    A,@DPTR
005D FE                MOV     R6,A
005E EF                MOV     A,R7
005F 2E                ADD     A,R6
0060 FF                MOV     R7,A
0061 900000      R     MOV     DPTR,#size
0064 EF                MOV     A,R7
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 711
0066         ?C0030:
                                           ; SOURCE LINE # 713
0066 9044C0            MOV     DPTR,#044C0H
0069 7404              MOV     A,#04H
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 722
006C 900000      R     MOV     DPTR,#size
006F E0                MOVX    A,@DPTR
0070 FF                MOV     R7,A
                                           ; SOURCE LINE # 723
0071         ?C0033:
0071 22                RET     
             ; FUNCTION UART_Servo_GetRxBufferSize (END)

             ; FUNCTION UART_Servo_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 757
                                           ; SOURCE LINE # 758
                                           ; SOURCE LINE # 762
0000 120000      E     LCALL   CyEnterCriticalSection
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 39  

0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 763
0008 906491            MOV     DPTR,#06491H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 764
0013 906491            MOV     DPTR,#06491H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 770
0026 9044C8            MOV     DPTR,#044C8H
0029 7404              MOV     A,#04H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 772
002C 900000      R     MOV     DPTR,#UART_Servo_rxBufferRead
002F E4                CLR     A
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 773
0031 900000      R     MOV     DPTR,#UART_Servo_rxBufferWrite
0034 E4                CLR     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 774
0036 900000      R     MOV     DPTR,#UART_Servo_rxBufferLoopDetect
0039 E4                CLR     A
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 775
003B 900000      R     MOV     DPTR,#UART_Servo_rxBufferOverflow
003E E4                CLR     A
003F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 777
0040 9044C0            MOV     DPTR,#044C0H
0043 7404              MOV     A,#04H
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 781
0046 22                RET     
             ; FUNCTION UART_Servo_ClearRxBuffer (END)

             ; FUNCTION _UART_Servo_SetRxAddressMode (BEGIN)
                                           ; SOURCE LINE # 813
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 815
                                           ; SOURCE LINE # 835
                                           ; SOURCE LINE # 836
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 40  

                                           ; SOURCE LINE # 838
                                           ; SOURCE LINE # 840
0005         ?C0036:
0005 22                RET     
             ; FUNCTION _UART_Servo_SetRxAddressMode (END)

             ; FUNCTION _UART_Servo_SetRxAddress1 (BEGIN)
                                           ; SOURCE LINE # 857
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 858
                                           ; SOURCE LINE # 859
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906421            MOV     DPTR,#06421H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 860
000F 22                RET     
             ; FUNCTION _UART_Servo_SetRxAddress1 (END)

             ; FUNCTION _UART_Servo_SetRxAddress2 (BEGIN)
                                           ; SOURCE LINE # 877
0000 900000      R     MOV     DPTR,#address
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 878
                                           ; SOURCE LINE # 879
0005 900000      R     MOV     DPTR,#address
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906431            MOV     DPTR,#06431H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 880
000F 22                RET     
             ; FUNCTION _UART_Servo_SetRxAddress2 (END)

             ; FUNCTION _UART_Servo_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 908
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 909
                                           ; SOURCE LINE # 910
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906484            MOV     DPTR,#06484H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 911
000F 22                RET     
             ; FUNCTION _UART_Servo_SetTxInterruptMode (END)

             ; FUNCTION _UART_Servo_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 942
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 41  

                                           ; SOURCE LINE # 943
                                           ; SOURCE LINE # 945
0005 900000      R     MOV     DPTR,#UART_Servo_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 600A              JZ      ?C0041
                                           ; SOURCE LINE # 946
                                           ; SOURCE LINE # 976
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 906444            MOV     DPTR,#06444H
0015 EF                MOV     A,R7
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 979
                                           ; SOURCE LINE # 980
0017         ?C0041:
0017 22                RET     
             ; FUNCTION _UART_Servo_WriteTxData (END)

             ; FUNCTION UART_Servo_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1003
                                           ; SOURCE LINE # 1004
                                           ; SOURCE LINE # 1005
0000 906464            MOV     DPTR,#06464H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1006
0005         ?C0042:
0005 22                RET     
             ; FUNCTION UART_Servo_ReadTxStatus (END)

             ; FUNCTION _UART_Servo_PutChar (BEGIN)
                                           ; SOURCE LINE # 1041
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1042
0005         ?C0043:
                                           ; SOURCE LINE # 1107
0005 906464            MOV     DPTR,#06464H
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 20E2F7            JB      ACC.2,?C0043
                                           ; SOURCE LINE # 1108
                                           ; SOURCE LINE # 1110
000E         ?C0044:
                                           ; SOURCE LINE # 1113
000E 900000      R     MOV     DPTR,#txDataByte
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 906444            MOV     DPTR,#06444H
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1116
0018 22                RET     
             ; FUNCTION _UART_Servo_PutChar (END)

             ; FUNCTION _UART_Servo_PutString (BEGIN)
                                           ; SOURCE LINE # 1145
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 42  

0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1146
                                           ; SOURCE LINE # 1147
0006 900000      R     MOV     DPTR,#bufIndex
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E4                CLR     A
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1150
000E 900000      R     MOV     DPTR,#UART_Servo_initVar
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 6042              JZ      ?C0049
                                           ; SOURCE LINE # 1151
0016         ?C0047:
                                           ; SOURCE LINE # 1153
0016 900000      R     MOV     DPTR,#string
0019 120000      E     LCALL   ?C?PLDXDATA
001C 900000      R     MOV     DPTR,#bufIndex
001F E0                MOVX    A,@DPTR
0020 FE                MOV     R6,A
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E9                MOV     A,R1
0025 2F                ADD     A,R7
0026 F9                MOV     R1,A
0027 EA                MOV     A,R2
0028 3E                ADDC    A,R6
0029 FA                MOV     R2,A
002A 120000      E     LCALL   ?C?CLDPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 6027              JZ      ?C0049
                                           ; SOURCE LINE # 1154
                                           ; SOURCE LINE # 1155
0031 900000      R     MOV     DPTR,#string
0034 120000      E     LCALL   ?C?PLDXDATA
0037 900000      R     MOV     DPTR,#bufIndex
003A E0                MOVX    A,@DPTR
003B FE                MOV     R6,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F E9                MOV     A,R1
0040 2F                ADD     A,R7
0041 F9                MOV     R1,A
0042 EA                MOV     A,R2
0043 3E                ADDC    A,R6
0044 FA                MOV     R2,A
0045 120000      E     LCALL   ?C?CLDPTR
0048 FF                MOV     R7,A
0049 120000      R     LCALL   _UART_Servo_PutChar
                                           ; SOURCE LINE # 1156
004C 900000      R     MOV     DPTR,#bufIndex
004F E4                CLR     A
0050 75F001            MOV     B,#01H
0053 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1157
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 43  

0056 80BE              SJMP    ?C0047
                                           ; SOURCE LINE # 1158
                                           ; SOURCE LINE # 1159
0058         ?C0049:
0058 22                RET     
             ; FUNCTION _UART_Servo_PutString (END)

             ; FUNCTION _UART_Servo_PutArray (BEGIN)
                                           ; SOURCE LINE # 1191
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1193
                                           ; SOURCE LINE # 1194
000B 900000      R     MOV     DPTR,#bufIndex
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1197
0010 900000      R     MOV     DPTR,#UART_Servo_initVar
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 602F              JZ      ?C0053
                                           ; SOURCE LINE # 1198
0018         ?C0051:
                                           ; SOURCE LINE # 1199
0018 900000      R     MOV     DPTR,#byteCount
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#bufIndex
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 EE                MOV     A,R6
0023 C3                CLR     C
0024 9F                SUBB    A,R7
0025 5020              JNC     ?C0053
                                           ; SOURCE LINE # 1200
                                           ; SOURCE LINE # 1201
0027 900000      R     MOV     DPTR,#string
002A 120000      E     LCALL   ?C?PLDXDATA
002D 900000      R     MOV     DPTR,#bufIndex
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 E9                MOV     A,R1
0033 2F                ADD     A,R7
0034 F9                MOV     R1,A
0035 E4                CLR     A
0036 3A                ADDC    A,R2
0037 FA                MOV     R2,A
0038 120000      E     LCALL   ?C?CLDPTR
003B FF                MOV     R7,A
003C 120000      R     LCALL   _UART_Servo_PutChar
                                           ; SOURCE LINE # 1202
003F 900000      R     MOV     DPTR,#bufIndex
0042 E0                MOVX    A,@DPTR
0043 04                INC     A
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1203
0045 80D1              SJMP    ?C0051
                                           ; SOURCE LINE # 1204
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 44  

                                           ; SOURCE LINE # 1205
0047         ?C0053:
0047 22                RET     
             ; FUNCTION _UART_Servo_PutArray (END)

             ; FUNCTION _UART_Servo_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1230
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1231
                                           ; SOURCE LINE # 1233
0005 900000      R     MOV     DPTR,#UART_Servo_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6012              JZ      ?C0055
                                           ; SOURCE LINE # 1234
                                           ; SOURCE LINE # 1235
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _UART_Servo_PutChar
                                           ; SOURCE LINE # 1236
0015 7F0D              MOV     R7,#0DH
0017 120000      R     LCALL   _UART_Servo_PutChar
                                           ; SOURCE LINE # 1237
001A 7F0A              MOV     R7,#0AH
001C 120000      R     LCALL   _UART_Servo_PutChar
                                           ; SOURCE LINE # 1238
                                           ; SOURCE LINE # 1239
001F         ?C0055:
001F 22                RET     
             ; FUNCTION _UART_Servo_PutCRLF (END)

             ; FUNCTION UART_Servo_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 1273
                                           ; SOURCE LINE # 1275
                                           ; SOURCE LINE # 1301
0000 906464            MOV     DPTR,#06464H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#size
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1304
000A 900000      R     MOV     DPTR,#size
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 30E208            JNB     ACC.2,?C0056
                                           ; SOURCE LINE # 1305
                                           ; SOURCE LINE # 1306
0013 900000      R     MOV     DPTR,#size
0016 7404              MOV     A,#04H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1307
0019 8016              SJMP    ?C0057
001B         ?C0056:
                                           ; SOURCE LINE # 1308
001B 900000      R     MOV     DPTR,#size
001E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 45  

001F FF                MOV     R7,A
0020 EF                MOV     A,R7
0021 30E107            JNB     ACC.1,?C0058
                                           ; SOURCE LINE # 1309
                                           ; SOURCE LINE # 1310
0024 900000      R     MOV     DPTR,#size
0027 E4                CLR     A
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1311
0029 8006              SJMP    ?C0057
002B         ?C0058:
                                           ; SOURCE LINE # 1313
                                           ; SOURCE LINE # 1315
002B 900000      R     MOV     DPTR,#size
002E 7401              MOV     A,#01H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1316
0031         ?C0057:
                                           ; SOURCE LINE # 1320
0031 900000      R     MOV     DPTR,#size
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
                                           ; SOURCE LINE # 1321
0036         ?C0060:
0036 22                RET     
             ; FUNCTION UART_Servo_GetTxBufferSize (END)

             ; FUNCTION UART_Servo_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 1354
                                           ; SOURCE LINE # 1355
                                           ; SOURCE LINE # 1358
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1360
0008 906494            MOV     DPTR,#06494H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1361
0013 906494            MOV     DPTR,#06494H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1362
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1376
0026 22                RET     
             ; FUNCTION UART_Servo_ClearTxBuffer (END)

C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 46  

             ; FUNCTION _UART_Servo_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1440
0000 900000      R     MOV     DPTR,#retMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1441
                                           ; SOURCE LINE # 1444
0005 900000      R     MOV     DPTR,#UART_Servo_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7003              JNZ     $ + 5H
000D 020000      R     LJMP    ?C0075
                                           ; SOURCE LINE # 1445
                                           ; SOURCE LINE # 1490
0010 900000      R     MOV     DPTR,#retMode
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 600A              JZ      ?C0064
0018 900000      R     MOV     DPTR,#retMode
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6403              XRL     A,#03H
0020 7032              JNZ     ?C0063
0022         ?C0064:
                                           ; SOURCE LINE # 1492
                                           ; SOURCE LINE # 1497
0022 120000      R     LCALL   UART_Servo_ReadControlRegister
0025 EF                MOV     A,R7
0026 4402              ORL     A,#02H
0028 FF                MOV     R7,A
0029 120000      R     LCALL   _UART_Servo_WriteControlRegister
                                           ; SOURCE LINE # 1501
002C 906433            MOV     DPTR,#06433H
002F E0                MOVX    A,@DPTR
0030 FF                MOV     R7,A
0031 900000      R     MOV     DPTR,#txPeriod
0034 EF                MOV     A,R7
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1502
0036 906433            MOV     DPTR,#06433H
0039 7467              MOV     A,#067H
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1509
003C 906444            MOV     DPTR,#06444H
003F E4                CLR     A
0040 F0                MOVX    @DPTR,A
0041         ?C0067:
                                           ; SOURCE LINE # 1512
                                           ; SOURCE LINE # 1513
0041 906464            MOV     DPTR,#06464H
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 900000      R     MOV     DPTR,#tmpStat
0049 EF                MOV     A,R7
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1514
                                           ; SOURCE LINE # 1515
004B 900000      R     MOV     DPTR,#tmpStat
004E E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 47  

004F FF                MOV     R7,A
0050 EF                MOV     A,R7
0051 20E1ED            JB      ACC.1,?C0067
                                           ; SOURCE LINE # 1516
0054         ?C0063:
                                           ; SOURCE LINE # 1518
0054 900000      R     MOV     DPTR,#retMode
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A 6401              XRL     A,#01H
005C 6009              JZ      ?C0072
005E 900000      R     MOV     DPTR,#retMode
0061 E0                MOVX    A,@DPTR
0062 FF                MOV     R7,A
0063 EF                MOV     A,R7
0064 B40316            CJNE    A,#03H,?C0068
                                           ; SOURCE LINE # 1520
0067         ?C0072:
                                           ; SOURCE LINE # 1522
                                           ; SOURCE LINE # 1523
0067 906464            MOV     DPTR,#06464H
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C 900000      R     MOV     DPTR,#tmpStat
006F EF                MOV     A,R7
0070 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1524
                                           ; SOURCE LINE # 1525
0071 900000      R     MOV     DPTR,#tmpStat
0074 E0                MOVX    A,@DPTR
0075 FF                MOV     R7,A
0076 EF                MOV     A,R7
0077 F4                CPL     A
0078 FF                MOV     R7,A
0079 EF                MOV     A,R7
007A 20E0EA            JB      ACC.0,?C0072
                                           ; SOURCE LINE # 1526
007D         ?C0068:
                                           ; SOURCE LINE # 1528
007D 900000      R     MOV     DPTR,#retMode
0080 E0                MOVX    A,@DPTR
0081 FF                MOV     R7,A
0082 EF                MOV     A,R7
0083 6401              XRL     A,#01H
0085 6013              JZ      ?C0074
0087 900000      R     MOV     DPTR,#retMode
008A E0                MOVX    A,@DPTR
008B FF                MOV     R7,A
008C EF                MOV     A,R7
008D 6402              XRL     A,#02H
008F 6009              JZ      ?C0074
0091 900000      R     MOV     DPTR,#retMode
0094 E0                MOVX    A,@DPTR
0095 FF                MOV     R7,A
0096 EF                MOV     A,R7
0097 B40314            CJNE    A,#03H,?C0075
009A         ?C0074:
                                           ; SOURCE LINE # 1531
                                           ; SOURCE LINE # 1534
009A 900000      R     MOV     DPTR,#txPeriod
009D E0                MOVX    A,@DPTR
C51 COMPILER V9.51   UART_SERVO                                                            12/03/2015 21:05:10 PAGE 48  

009E FF                MOV     R7,A
009F 906433            MOV     DPTR,#06433H
00A2 EF                MOV     A,R7
00A3 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1542
00A4 120000      R     LCALL   UART_Servo_ReadControlRegister
00A7 EF                MOV     A,R7
00A8 54FD              ANL     A,#0FDH
00AA FF                MOV     R7,A
00AB 120000      R     LCALL   _UART_Servo_WriteControlRegister
                                           ; SOURCE LINE # 1544
                                           ; SOURCE LINE # 1546
                                           ; SOURCE LINE # 1547
00AE         ?C0075:
00AE 22                RET     
             ; FUNCTION _UART_Servo_SendBreak (END)

             ; FUNCTION _UART_Servo_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1572
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1573
                                           ; SOURCE LINE # 1575
                                           ; SOURCE LINE # 1576
                                           ; SOURCE LINE # 1581
0005         ?C0076:
                                           ; SOURCE LINE # 1583
                                           ; SOURCE LINE # 1588
                                           ; SOURCE LINE # 1589
0005         ?C0078:
0005 22                RET     
             ; FUNCTION _UART_Servo_SetTxAddressMode (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1404    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    262      38
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
