C51 COMPILER V9.51   UART_DEBUG_INT                                                        12/05/2015 15:02:20 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_DEBUG_INT
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\UART_Debug_INT.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\UART_Debug_INT.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF
                    -(DEBUG) WL(2) PR(.\DP8051\DP8051_Keil_951\Debug/UART_Debug_INT.lst) CD OT(2,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\UART
                    -_Debug_INT.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART_DebugINT.c
   3          * Version 2.50
   4          *
   5          * Description:
   6          *  This file provides all Interrupt Service functionality of the UART component
   7          *
   8          ********************************************************************************
   9          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  10          * You may use this file only in accordance with the license, terms, conditions,
  11          * disclaimers, and limitations in the end user license agreement accompanying
  12          * the software package with which this file was provided.
  13          *******************************************************************************/
  14          
  15          #include "UART_Debug.h"
  16          #include "cyapicallbacks.h"
  17          
  18          
  19          /***************************************
  20          * Custom Declarations
  21          ***************************************/
  22          /* `#START CUSTOM_DECLARATIONS` Place your declaration here */
  23          
  24          /* `#END` */
  25          
  26          #if (UART_Debug_RX_INTERRUPT_ENABLED && (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED))
                  /*******************************************************************************
                  * Function Name: UART_Debug_RXISR
                  ********************************************************************************
                  *
                  * Summary:
                  *  Interrupt Service Routine for RX portion of the UART
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_Debug_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_Debug_rxBufferWrite - cyclic index for write to rxBuffer,
                  *     increments after each byte saved to buffer.
                  *  UART_Debug_rxBufferRead - cyclic index for read from rxBuffer,
                  *     checked to detect overflow condition.
                  *  UART_Debug_rxBufferOverflow - software overflow flag. Set to one
                  *     when UART_Debug_rxBufferWrite index overtakes
                  *     UART_Debug_rxBufferRead index.
                  *  UART_Debug_rxBufferLoopDetect - additional variable to detect overflow.
                  *     Set to one when UART_Debug_rxBufferWrite is equal to
                  *    UART_Debug_rxBufferRead
                  *  UART_Debug_rxAddressMode - this variable contains the Address mode,
C51 COMPILER V9.51   UART_DEBUG_INT                                                        12/05/2015 15:02:20 PAGE 2   

                  *     selected in customizer or set by UART_SetRxAddressMode() API.
                  *  UART_Debug_rxAddressDetected - set to 1 when correct address received,
                  *     and analysed to store following addressed data bytes to the buffer.
                  *     When not correct address received, set to 0 to skip following data bytes.
                  *
                  *******************************************************************************/
                  CY_ISR(UART_Debug_RXISR)
                  {
                      uint8 readData;
                      uint8 readStatus;
                      uint8 increment_pointer = 0u;
              
                  #if(CY_PSOC3)
                      uint8 int_en;
                  #endif /* (CY_PSOC3) */
              
                  #ifdef UART_Debug_RXISR_ENTRY_CALLBACK
                      UART_Debug_RXISR_EntryCallback();
                  #endif /* UART_Debug_RXISR_ENTRY_CALLBACK */
              
                      /* User code required at start of ISR */
                      /* `#START UART_Debug_RXISR_START` */
              
                      /* `#END` */
              
                  #if(CY_PSOC3)   /* Make sure nested interrupt is enabled */
                      int_en = EA;
                      CyGlobalIntEnable;
                  #endif /* (CY_PSOC3) */
              
                      do
                      {
                          /* Read receiver status register */
                          readStatus = UART_Debug_RXSTATUS_REG;
                          /* Copy the same status to readData variable for backward compatibility support 
                          *  of the user code in UART_Debug_RXISR_ERROR` section. 
                          */
                          readData = readStatus;
              
                          if((readStatus & (UART_Debug_RX_STS_BREAK | 
                                          UART_Debug_RX_STS_PAR_ERROR |
                                          UART_Debug_RX_STS_STOP_ERROR | 
                                          UART_Debug_RX_STS_OVERRUN)) != 0u)
                          {
                              /* ERROR handling. */
                              UART_Debug_errorStatus |= readStatus & ( UART_Debug_RX_STS_BREAK | 
                                                                          UART_Debug_RX_STS_PAR_ERROR | 
                                                                          UART_Debug_RX_STS_STOP_ERROR | 
                                                                          UART_Debug_RX_STS_OVERRUN);
                              /* `#START UART_Debug_RXISR_ERROR` */
              
                              /* `#END` */
                              
                          #ifdef UART_Debug_RXISR_ERROR_CALLBACK
                              UART_Debug_RXISR_ERROR_Callback();
                          #endif /* UART_Debug_RXISR_ERROR_CALLBACK */
                          }
                          
                          if((readStatus & UART_Debug_RX_STS_FIFO_NOTEMPTY) != 0u)
                          {
                              /* Read data from the RX data register */
                              readData = UART_Debug_RXDATA_REG;
C51 COMPILER V9.51   UART_DEBUG_INT                                                        12/05/2015 15:02:20 PAGE 3   

                          #if (UART_Debug_RXHW_ADDRESS_ENABLED)
                              if(UART_Debug_rxAddressMode == (uint8)UART_Debug__B_UART__AM_SW_DETECT_TO_BUFFER)
                              {
                                  if((readStatus & UART_Debug_RX_STS_MRKSPC) != 0u)
                                  {
                                      if ((readStatus & UART_Debug_RX_STS_ADDR_MATCH) != 0u)
                                      {
                                          UART_Debug_rxAddressDetected = 1u;
                                      }
                                      else
                                      {
                                          UART_Debug_rxAddressDetected = 0u;
                                      }
                                  }
                                  if(UART_Debug_rxAddressDetected != 0u)
                                  {   /* Store only addressed data */
                                      UART_Debug_rxBuffer[UART_Debug_rxBufferWrite] = readData;
                                      increment_pointer = 1u;
                                  }
                              }
                              else /* Without software addressing */
                              {
                                  UART_Debug_rxBuffer[UART_Debug_rxBufferWrite] = readData;
                                  increment_pointer = 1u;
                              }
                          #else  /* Without addressing */
                              UART_Debug_rxBuffer[UART_Debug_rxBufferWrite] = readData;
                              increment_pointer = 1u;
                          #endif /* (UART_Debug_RXHW_ADDRESS_ENABLED) */
              
                              /* Do not increment buffer pointer when skip not addressed data */
                              if(increment_pointer != 0u)
                              {
                                  if(UART_Debug_rxBufferLoopDetect != 0u)
                                  {   /* Set Software Buffer status Overflow */
                                      UART_Debug_rxBufferOverflow = 1u;
                                  }
                                  /* Set next pointer. */
                                  UART_Debug_rxBufferWrite++;
              
                                  /* Check pointer for a loop condition */
                                  if(UART_Debug_rxBufferWrite >= UART_Debug_RX_BUFFER_SIZE)
                                  {
                                      UART_Debug_rxBufferWrite = 0u;
                                  }
              
                                  /* Detect pre-overload condition and set flag */
                                  if(UART_Debug_rxBufferWrite == UART_Debug_rxBufferRead)
                                  {
                                      UART_Debug_rxBufferLoopDetect = 1u;
                                      /* When Hardware Flow Control selected */
                                      #if (UART_Debug_FLOW_CONTROL != 0u)
                                          /* Disable RX interrupt mask, it is enabled when user read data from the buffe
             -r using APIs */
                                          UART_Debug_RXSTATUS_MASK_REG  &= (uint8)~UART_Debug_RX_STS_FIFO_NOTEMPTY;
                                          CyIntClearPending(UART_Debug_RX_VECT_NUM);
                                          break; /* Break the reading of the FIFO loop, leave the data there for generat
             -ing RTS signal */
                                      #endif /* (UART_Debug_FLOW_CONTROL != 0u) */
                                  }
                              }
                          }
C51 COMPILER V9.51   UART_DEBUG_INT                                                        12/05/2015 15:02:20 PAGE 4   

                      }while((readStatus & UART_Debug_RX_STS_FIFO_NOTEMPTY) != 0u);
              
                      /* User code required at end of ISR (Optional) */
                      /* `#START UART_Debug_RXISR_END` */
              
                      /* `#END` */
              
                  #ifdef UART_Debug_RXISR_EXIT_CALLBACK
                      UART_Debug_RXISR_ExitCallback();
                  #endif /* UART_Debug_RXISR_EXIT_CALLBACK */
              
                  #if(CY_PSOC3)
                      EA = int_en;
                  #endif /* (CY_PSOC3) */
                  }
                  
              #endif /* (UART_Debug_RX_INTERRUPT_ENABLED && (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED)) */
 192          
 193          
 194          #if (UART_Debug_TX_INTERRUPT_ENABLED && UART_Debug_TX_ENABLED)
 195              /*******************************************************************************
 196              * Function Name: UART_Debug_TXISR
 197              ********************************************************************************
 198              *
 199              * Summary:
 200              * Interrupt Service Routine for the TX portion of the UART
 201              *
 202              * Parameters:
 203              *  None.
 204              *
 205              * Return:
 206              *  None.
 207              *
 208              * Global Variables:
 209              *  UART_Debug_txBuffer - RAM buffer pointer for transmit data from.
 210              *  UART_Debug_txBufferRead - cyclic index for read and transmit data
 211              *     from txBuffer, increments after each transmitted byte.
 212              *  UART_Debug_rxBufferWrite - cyclic index for write to txBuffer,
 213              *     checked to detect available for transmission bytes.
 214              *
 215              *******************************************************************************/
 216              CY_ISR(UART_Debug_TXISR)
 217              {
 218   1          #if(CY_PSOC3)
 219   1              uint8 int_en;
 220   1          #endif /* (CY_PSOC3) */
 221   1      
 222   1          #ifdef UART_Debug_TXISR_ENTRY_CALLBACK
                      UART_Debug_TXISR_EntryCallback();
                  #endif /* UART_Debug_TXISR_ENTRY_CALLBACK */
 225   1      
 226   1              /* User code required at start of ISR */
 227   1              /* `#START UART_Debug_TXISR_START` */
 228   1      
 229   1              /* `#END` */
 230   1      
 231   1          #if(CY_PSOC3)   /* Make sure nested interrupt is enabled */
 232   1              int_en = EA;
 233   1              CyGlobalIntEnable;
 234   1          #endif /* (CY_PSOC3) */
 235   1      
 236   1              while((UART_Debug_txBufferRead != UART_Debug_txBufferWrite) &&
C51 COMPILER V9.51   UART_DEBUG_INT                                                        12/05/2015 15:02:20 PAGE 5   

 237   1                   ((UART_Debug_TXSTATUS_REG & UART_Debug_TX_STS_FIFO_FULL) == 0u))
 238   1              {
 239   2                  /* Check pointer wrap around */
 240   2                  if(UART_Debug_txBufferRead >= UART_Debug_TX_BUFFER_SIZE)
 241   2                  {
 242   3                      UART_Debug_txBufferRead = 0u;
 243   3                  }
 244   2      
 245   2                  UART_Debug_TXDATA_REG = UART_Debug_txBuffer[UART_Debug_txBufferRead];
 246   2      
 247   2                  /* Set next pointer */
 248   2                  UART_Debug_txBufferRead++;
 249   2              }
 250   1      
 251   1              /* User code required at end of ISR (Optional) */
 252   1              /* `#START UART_Debug_TXISR_END` */
 253   1      
 254   1              /* `#END` */
 255   1      
 256   1          #ifdef UART_Debug_TXISR_EXIT_CALLBACK
                      UART_Debug_TXISR_ExitCallback();
                  #endif /* UART_Debug_TXISR_EXIT_CALLBACK */
 259   1      
 260   1          #if(CY_PSOC3)
 261   1              EA = int_en;
 262   1          #endif /* (CY_PSOC3) */
 263   1         }
 264          #endif /* (UART_Debug_TX_INTERRUPT_ENABLED && UART_Debug_TX_ENABLED) */
 265          
 266          
 267          /* [] END OF FILE */
C51 COMPILER V9.51   UART_DEBUG_INT                                                        12/05/2015 15:02:20 PAGE 6   

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_Debug_TXISR (BEGIN)
0000 C0E0              PUSH    ACC
0002 C083              PUSH    DPH
0004 C082              PUSH    DPL
0006 C085              PUSH    DPH1
0008 C084              PUSH    DPL1
000A C086              PUSH    DPS
000C 758600            MOV     DPS,#00H
000F C000        E     PUSH    ?C?XPAGE1SFR
0011 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0014 C0D0              PUSH    PSW
0016 75D000            MOV     PSW,#00H
0019 C006              PUSH    AR6
001B C007              PUSH    AR7
                                           ; SOURCE LINE # 216
                                           ; SOURCE LINE # 232
001D A2AF              MOV     C,EA
001F E4                CLR     A
0020 33                RLC     A
0021 FF                MOV     R7,A
0022 900000      R     MOV     DPTR,#int_en
0025 EF                MOV     A,R7
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 233
0027 D2AF              SETB    EA
0029 9044F4            MOV     DPTR,#044F4H
002C 74FD              MOV     A,#0FDH
002E F0                MOVX    @DPTR,A
002F         ?C0001:
                                           ; SOURCE LINE # 237
002F 900000      E     MOV     DPTR,#UART_Debug_txBufferWrite
0032 E0                MOVX    A,@DPTR
0033 FF                MOV     R7,A
0034 900000      E     MOV     DPTR,#UART_Debug_txBufferRead
0037 E0                MOVX    A,@DPTR
0038 FE                MOV     R6,A
0039 EE                MOV     A,R6
003A 6F                XRL     A,R7
003B 6037              JZ      ?C0002
003D 906464            MOV     DPTR,#06464H
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 EF                MOV     A,R7
0043 20E22E            JB      ACC.2,?C0002
                                           ; SOURCE LINE # 238
                                           ; SOURCE LINE # 240
0046 900000      E     MOV     DPTR,#UART_Debug_txBufferRead
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
004B EF                MOV     A,R7
004C C3                CLR     C
004D 9464              SUBB    A,#064H
004F 4005              JC      ?C0003
                                           ; SOURCE LINE # 241
                                           ; SOURCE LINE # 242
0051 900000      E     MOV     DPTR,#UART_Debug_txBufferRead
0054 E4                CLR     A
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 243
C51 COMPILER V9.51   UART_DEBUG_INT                                                        12/05/2015 15:02:20 PAGE 7   

0056         ?C0003:
                                           ; SOURCE LINE # 245
0056 900000      E     MOV     DPTR,#UART_Debug_txBufferRead
0059 E0                MOVX    A,@DPTR
005A FF                MOV     R7,A
005B 7400        E     MOV     A,#LOW UART_Debug_txBuffer
005D 2F                ADD     A,R7
005E F582              MOV     DPL,A
0060 E4                CLR     A
0061 3400        E     ADDC    A,#HIGH UART_Debug_txBuffer
0063 F583              MOV     DPH,A
0065 E0                MOVX    A,@DPTR
0066 FF                MOV     R7,A
0067 906444            MOV     DPTR,#06444H
006A EF                MOV     A,R7
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 248
006C 900000      E     MOV     DPTR,#UART_Debug_txBufferRead
006F E0                MOVX    A,@DPTR
0070 04                INC     A
0071 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 249
0072 80BB              SJMP    ?C0001
0074         ?C0002:
                                           ; SOURCE LINE # 261
0074 900000      R     MOV     DPTR,#int_en
0077 E0                MOVX    A,@DPTR
0078 FF                MOV     R7,A
0079 EF                MOV     A,R7
007A 24FF              ADD     A,#0FFH
007C 92AF              MOV     EA,C
                                           ; SOURCE LINE # 263
007E D007              POP     AR7
0080 D006              POP     AR6
0082 D0D0              POP     PSW
0084 D000        E     POP     ?C?XPAGE1SFR
0086 D086              POP     DPS
0088 D084              POP     DPL1
008A D085              POP     DPH1
008C D082              POP     DPL
008E D083              POP     DPH
0090 D0E0              POP     ACC
0092 32                RETI    
             ; FUNCTION UART_Debug_TXISR (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    147    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
