C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART_DEBUG
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\UART_Debug.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.3\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\UART_Debug.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DEB
                    -UG) WL(2) PR(.\DP8051\DP8051_Keil_951\Debug/UART_Debug.lst) CD OT(2,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\UART_Debug.o
                    -bj)

line level    source

   1          /*******************************************************************************
   2          * File Name: UART_Debug.c
   3          * Version 2.50
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the UART component
   7          *
   8          * Note:
   9          *
  10          ********************************************************************************
  11          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  12          * You may use this file only in accordance with the license, terms, conditions,
  13          * disclaimers, and limitations in the end user license agreement accompanying
  14          * the software package with which this file was provided.
  15          *******************************************************************************/
  16          
  17          #include "UART_Debug.h"
  18          #if (UART_Debug_INTERNAL_CLOCK_USED)
  19              #include "UART_Debug_IntClock.h"
  20          #endif /* End UART_Debug_INTERNAL_CLOCK_USED */
  21          
  22          
  23          /***************************************
  24          * Global data allocation
  25          ***************************************/
  26          
  27          uint8 UART_Debug_initVar = 0u;
  28          
  29          #if (UART_Debug_TX_INTERRUPT_ENABLED && UART_Debug_TX_ENABLED)
  30              volatile uint8 UART_Debug_txBuffer[UART_Debug_TX_BUFFER_SIZE];
  31              volatile uint8 UART_Debug_txBufferRead = 0u;
  32              uint8 UART_Debug_txBufferWrite = 0u;
  33          #endif /* (UART_Debug_TX_INTERRUPT_ENABLED && UART_Debug_TX_ENABLED) */
  34          
  35          #if (UART_Debug_RX_INTERRUPT_ENABLED && (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED))
                  uint8 UART_Debug_errorStatus = 0u;
                  volatile uint8 UART_Debug_rxBuffer[UART_Debug_RX_BUFFER_SIZE];
                  volatile uint8 UART_Debug_rxBufferRead  = 0u;
                  volatile uint8 UART_Debug_rxBufferWrite = 0u;
                  volatile uint8 UART_Debug_rxBufferLoopDetect = 0u;
                  volatile uint8 UART_Debug_rxBufferOverflow   = 0u;
                  #if (UART_Debug_RXHW_ADDRESS_ENABLED)
                      volatile uint8 UART_Debug_rxAddressMode = UART_Debug_RX_ADDRESS_MODE;
                      volatile uint8 UART_Debug_rxAddressDetected = 0u;
                  #endif /* (UART_Debug_RXHW_ADDRESS_ENABLED) */
              #endif /* (UART_Debug_RX_INTERRUPT_ENABLED && (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED)) */
  47          
  48          
  49          /*******************************************************************************
  50          * Function Name: UART_Debug_Start
  51          ********************************************************************************
  52          *
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 2   

  53          * Summary:
  54          *  This is the preferred method to begin component operation.
  55          *  UART_Debug_Start() sets the initVar variable, calls the
  56          *  UART_Debug_Init() function, and then calls the
  57          *  UART_Debug_Enable() function.
  58          *
  59          * Parameters:
  60          *  None.
  61          *
  62          * Return:
  63          *  None.
  64          *
  65          * Global variables:
  66          *  The UART_Debug_intiVar variable is used to indicate initial
  67          *  configuration of this component. The variable is initialized to zero (0u)
  68          *  and set to one (1u) the first time UART_Debug_Start() is called. This
  69          *  allows for component initialization without re-initialization in all
  70          *  subsequent calls to the UART_Debug_Start() routine.
  71          *
  72          * Reentrant:
  73          *  No.
  74          *
  75          *******************************************************************************/
  76          void UART_Debug_Start(void) 
  77          {
  78   1          /* If not initialized then initialize all required hardware and software */
  79   1          if(UART_Debug_initVar == 0u)
  80   1          {
  81   2              UART_Debug_Init();
  82   2              UART_Debug_initVar = 1u;
  83   2          }
  84   1      
  85   1          UART_Debug_Enable();
  86   1      }
  87          
  88          
  89          /*******************************************************************************
  90          * Function Name: UART_Debug_Init
  91          ********************************************************************************
  92          *
  93          * Summary:
  94          *  Initializes or restores the component according to the customizer Configure
  95          *  dialog settings. It is not necessary to call UART_Debug_Init() because
  96          *  the UART_Debug_Start() API calls this function and is the preferred
  97          *  method to begin component operation.
  98          *
  99          * Parameters:
 100          *  None.
 101          *
 102          * Return:
 103          *  None.
 104          *
 105          *******************************************************************************/
 106          void UART_Debug_Init(void) 
 107          {
 108   1          #if(UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED)
              
                      #if (UART_Debug_RX_INTERRUPT_ENABLED)
                          /* Set RX interrupt vector and priority */
                          (void) CyIntSetVector(UART_Debug_RX_VECT_NUM, &UART_Debug_RXISR);
                          CyIntSetPriority(UART_Debug_RX_VECT_NUM, UART_Debug_RX_PRIOR_NUM);
                          UART_Debug_errorStatus = 0u;
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 3   

                      #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
              
                      #if (UART_Debug_RXHW_ADDRESS_ENABLED)
                          UART_Debug_SetRxAddressMode(UART_Debug_RX_ADDRESS_MODE);
                          UART_Debug_SetRxAddress1(UART_Debug_RX_HW_ADDRESS1);
                          UART_Debug_SetRxAddress2(UART_Debug_RX_HW_ADDRESS2);
                      #endif /* End UART_Debug_RXHW_ADDRESS_ENABLED */
              
                      /* Init Count7 period */
                      UART_Debug_RXBITCTR_PERIOD_REG = UART_Debug_RXBITCTR_INIT;
                      /* Configure the Initial RX interrupt mask */
                      UART_Debug_RXSTATUS_MASK_REG  = UART_Debug_INIT_RX_INTERRUPTS_MASK;
                  #endif /* End UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED*/
 128   1      
 129   1          #if(UART_Debug_TX_ENABLED)
 130   1              #if (UART_Debug_TX_INTERRUPT_ENABLED)
 131   1                  /* Set TX interrupt vector and priority */
 132   1                  (void) CyIntSetVector(UART_Debug_TX_VECT_NUM, &UART_Debug_TXISR);
 133   1                  CyIntSetPriority(UART_Debug_TX_VECT_NUM, UART_Debug_TX_PRIOR_NUM);
 134   1              #endif /* (UART_Debug_TX_INTERRUPT_ENABLED) */
 135   1      
 136   1              /* Write Counter Value for TX Bit Clk Generator*/
 137   1              #if (UART_Debug_TXCLKGEN_DP)
 138   1                  UART_Debug_TXBITCLKGEN_CTR_REG = UART_Debug_BIT_CENTER;
 139   1                  UART_Debug_TXBITCLKTX_COMPLETE_REG = ((UART_Debug_NUMBER_OF_DATA_BITS +
 140   1                              UART_Debug_NUMBER_OF_START_BIT) * UART_Debug_OVER_SAMPLE_COUNT) - 1u;
 141   1              #else
                          UART_Debug_TXBITCTR_PERIOD_REG = ((UART_Debug_NUMBER_OF_DATA_BITS +
                                      UART_Debug_NUMBER_OF_START_BIT) * UART_Debug_OVER_SAMPLE_8) - 1u;
                      #endif /* End UART_Debug_TXCLKGEN_DP */
 145   1      
 146   1              /* Configure the Initial TX interrupt mask */
 147   1              #if (UART_Debug_TX_INTERRUPT_ENABLED)
 148   1                  UART_Debug_TXSTATUS_MASK_REG = UART_Debug_TX_STS_FIFO_EMPTY;
 149   1              #else
                          UART_Debug_TXSTATUS_MASK_REG = UART_Debug_INIT_TX_INTERRUPTS_MASK;
                      #endif /*End UART_Debug_TX_INTERRUPT_ENABLED*/
 152   1      
 153   1          #endif /* End UART_Debug_TX_ENABLED */
 154   1      
 155   1          #if(UART_Debug_PARITY_TYPE_SW)  /* Write Parity to Control Register */
                      UART_Debug_WriteControlRegister( \
                          (UART_Debug_ReadControlRegister() & (uint8)~UART_Debug_CTRL_PARITY_TYPE_MASK) | \
                          (uint8)(UART_Debug_PARITY_TYPE << UART_Debug_CTRL_PARITY_TYPE0_SHIFT) );
                  #endif /* End UART_Debug_PARITY_TYPE_SW */
 160   1      }
 161          
 162          
 163          /*******************************************************************************
 164          * Function Name: UART_Debug_Enable
 165          ********************************************************************************
 166          *
 167          * Summary:
 168          *  Activates the hardware and begins component operation. It is not necessary
 169          *  to call UART_Debug_Enable() because the UART_Debug_Start() API
 170          *  calls this function, which is the preferred method to begin component
 171          *  operation.
 172          
 173          * Parameters:
 174          *  None.
 175          *
 176          * Return:
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 4   

 177          *  None.
 178          *
 179          * Global Variables:
 180          *  UART_Debug_rxAddressDetected - set to initial state (0).
 181          *
 182          *******************************************************************************/
 183          void UART_Debug_Enable(void) 
 184          {
 185   1          uint8 enableInterrupts;
 186   1          enableInterrupts = CyEnterCriticalSection();
 187   1      
 188   1          #if (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED)
                      /* RX Counter (Count7) Enable */
                      UART_Debug_RXBITCTR_CONTROL_REG |= UART_Debug_CNTR_ENABLE;
              
                      /* Enable the RX Interrupt */
                      UART_Debug_RXSTATUS_ACTL_REG  |= UART_Debug_INT_ENABLE;
              
                      #if (UART_Debug_RX_INTERRUPT_ENABLED)
                          UART_Debug_EnableRxInt();
              
                          #if (UART_Debug_RXHW_ADDRESS_ENABLED)
                              UART_Debug_rxAddressDetected = 0u;
                          #endif /* (UART_Debug_RXHW_ADDRESS_ENABLED) */
                      #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
                  #endif /* (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED) */
 203   1      
 204   1          #if(UART_Debug_TX_ENABLED)
 205   1              /* TX Counter (DP/Count7) Enable */
 206   1              #if(!UART_Debug_TXCLKGEN_DP)
                          UART_Debug_TXBITCTR_CONTROL_REG |= UART_Debug_CNTR_ENABLE;
                      #endif /* End UART_Debug_TXCLKGEN_DP */
 209   1      
 210   1              /* Enable the TX Interrupt */
 211   1              UART_Debug_TXSTATUS_ACTL_REG |= UART_Debug_INT_ENABLE;
 212   1              #if (UART_Debug_TX_INTERRUPT_ENABLED)
 213   1                  UART_Debug_ClearPendingTxInt(); /* Clear history of TX_NOT_EMPTY */
 214   1                  UART_Debug_EnableTxInt();
 215   1              #endif /* (UART_Debug_TX_INTERRUPT_ENABLED) */
 216   1           #endif /* (UART_Debug_TX_INTERRUPT_ENABLED) */
 217   1      
 218   1          #if (UART_Debug_INTERNAL_CLOCK_USED)
 219   1              UART_Debug_IntClock_Start();  /* Enable the clock */
 220   1          #endif /* (UART_Debug_INTERNAL_CLOCK_USED) */
 221   1      
 222   1          CyExitCriticalSection(enableInterrupts);
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: UART_Debug_Stop
 228          ********************************************************************************
 229          *
 230          * Summary:
 231          *  Disables the UART operation.
 232          *
 233          * Parameters:
 234          *  None.
 235          *
 236          * Return:
 237          *  None.
 238          *
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 5   

 239          *******************************************************************************/
 240          void UART_Debug_Stop(void) 
 241          {
 242   1          uint8 enableInterrupts;
 243   1          enableInterrupts = CyEnterCriticalSection();
 244   1      
 245   1          /* Write Bit Counter Disable */
 246   1          #if (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED)
                      UART_Debug_RXBITCTR_CONTROL_REG &= (uint8) ~UART_Debug_CNTR_ENABLE;
                  #endif /* (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED) */
 249   1      
 250   1          #if (UART_Debug_TX_ENABLED)
 251   1              #if(!UART_Debug_TXCLKGEN_DP)
                          UART_Debug_TXBITCTR_CONTROL_REG &= (uint8) ~UART_Debug_CNTR_ENABLE;
                      #endif /* (!UART_Debug_TXCLKGEN_DP) */
 254   1          #endif /* (UART_Debug_TX_ENABLED) */
 255   1      
 256   1          #if (UART_Debug_INTERNAL_CLOCK_USED)
 257   1              UART_Debug_IntClock_Stop();   /* Disable the clock */
 258   1          #endif /* (UART_Debug_INTERNAL_CLOCK_USED) */
 259   1      
 260   1          /* Disable internal interrupt component */
 261   1          #if (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED)
                      UART_Debug_RXSTATUS_ACTL_REG  &= (uint8) ~UART_Debug_INT_ENABLE;
              
                      #if (UART_Debug_RX_INTERRUPT_ENABLED)
                          UART_Debug_DisableRxInt();
                      #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
                  #endif /* (UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED) */
 268   1      
 269   1          #if (UART_Debug_TX_ENABLED)
 270   1              UART_Debug_TXSTATUS_ACTL_REG &= (uint8) ~UART_Debug_INT_ENABLE;
 271   1      
 272   1              #if (UART_Debug_TX_INTERRUPT_ENABLED)
 273   1                  UART_Debug_DisableTxInt();
 274   1              #endif /* (UART_Debug_TX_INTERRUPT_ENABLED) */
 275   1          #endif /* (UART_Debug_TX_ENABLED) */
 276   1      
 277   1          CyExitCriticalSection(enableInterrupts);
 278   1      }
 279          
 280          
 281          /*******************************************************************************
 282          * Function Name: UART_Debug_ReadControlRegister
 283          ********************************************************************************
 284          *
 285          * Summary:
 286          *  Returns the current value of the control register.
 287          *
 288          * Parameters:
 289          *  None.
 290          *
 291          * Return:
 292          *  Contents of the control register.
 293          *
 294          *******************************************************************************/
 295          uint8 UART_Debug_ReadControlRegister(void) 
 296          {
 297   1          #if (UART_Debug_CONTROL_REG_REMOVED)
 298   1              return(0u);
 299   1          #else
                      return(UART_Debug_CONTROL_REG);
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 6   

                  #endif /* (UART_Debug_CONTROL_REG_REMOVED) */
 302   1      }
 303          
 304          
 305          /*******************************************************************************
 306          * Function Name: UART_Debug_WriteControlRegister
 307          ********************************************************************************
 308          *
 309          * Summary:
 310          *  Writes an 8-bit value into the control register
 311          *
 312          * Parameters:
 313          *  control:  control register value
 314          *
 315          * Return:
 316          *  None.
 317          *
 318          *******************************************************************************/
 319          void  UART_Debug_WriteControlRegister(uint8 control) 
 320          {
 321   1          #if (UART_Debug_CONTROL_REG_REMOVED)
 322   1              if(0u != control)
 323   1              {
 324   2                  /* Suppress compiler warning */
 325   2              }
 326   1          #else
                     UART_Debug_CONTROL_REG = control;
                  #endif /* (UART_Debug_CONTROL_REG_REMOVED) */
 329   1      }
 330          
 331          
 332          #if(UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED)
                  /*******************************************************************************
                  * Function Name: UART_Debug_SetRxInterruptMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the RX interrupt sources enabled.
                  *
                  * Parameters:
                  *  IntSrc:  Bit field containing the RX interrupts to enable. Based on the 
                  *  bit-field arrangement of the status register. This value must be a 
                  *  combination of status register bit-masks shown below:
                  *      UART_Debug_RX_STS_FIFO_NOTEMPTY    Interrupt on byte received.
                  *      UART_Debug_RX_STS_PAR_ERROR        Interrupt on parity error.
                  *      UART_Debug_RX_STS_STOP_ERROR       Interrupt on stop error.
                  *      UART_Debug_RX_STS_BREAK            Interrupt on break.
                  *      UART_Debug_RX_STS_OVERRUN          Interrupt on overrun error.
                  *      UART_Debug_RX_STS_ADDR_MATCH       Interrupt on address match.
                  *      UART_Debug_RX_STS_MRKSPC           Interrupt on address detect.
                  *
                  * Return:
                  *  None.
                  *
                  * Theory:
                  *  Enables the output of specific status bits to the interrupt controller
                  *
                  *******************************************************************************/
                  void UART_Debug_SetRxInterruptMode(uint8 intSrc) 
                  {
                      UART_Debug_RXSTATUS_MASK_REG  = intSrc;
                  }
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 7   

              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_ReadRxData
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the next byte of received data. This function returns data without
                  *  checking the status. You must check the status separately.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Received data from RX register
                  *
                  * Global Variables:
                  *  UART_Debug_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_Debug_rxBufferWrite - cyclic index for write to rxBuffer,
                  *     checked to identify new data.
                  *  UART_Debug_rxBufferRead - cyclic index for read from rxBuffer,
                  *     incremented after each byte has been read from buffer.
                  *  UART_Debug_rxBufferLoopDetect - cleared if loop condition was detected
                  *     in RX ISR.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint8 UART_Debug_ReadRxData(void) 
                  {
                      uint8 rxData;
              
                  #if (UART_Debug_RX_INTERRUPT_ENABLED)
              
                      uint8 locRxBufferRead;
                      uint8 locRxBufferWrite;
              
                      /* Protect variables that could change on interrupt */
                      UART_Debug_DisableRxInt();
              
                      locRxBufferRead  = UART_Debug_rxBufferRead;
                      locRxBufferWrite = UART_Debug_rxBufferWrite;
              
                      if( (UART_Debug_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
                      {
                          rxData = UART_Debug_rxBuffer[locRxBufferRead];
                          locRxBufferRead++;
              
                          if(locRxBufferRead >= UART_Debug_RX_BUFFER_SIZE)
                          {
                              locRxBufferRead = 0u;
                          }
                          /* Update the real pointer */
                          UART_Debug_rxBufferRead = locRxBufferRead;
              
                          if(UART_Debug_rxBufferLoopDetect != 0u)
                          {
                              UART_Debug_rxBufferLoopDetect = 0u;
                              #if ((UART_Debug_RX_INTERRUPT_ENABLED) && (UART_Debug_FLOW_CONTROL != 0u))
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_Debug_HD_ENABLED )
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 8   

                                      if((UART_Debug_CONTROL_REG & UART_Debug_CTRL_HD_SEND) == 0u)
                                      {   /* In Half duplex mode return RX mask only in RX
                                          *  configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_Debug_RXSTATUS_MASK_REG  |= UART_Debug_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_Debug_RXSTATUS_MASK_REG  |= UART_Debug_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_Debug_HD_ENABLED */
                              #endif /* ((UART_Debug_RX_INTERRUPT_ENABLED) && (UART_Debug_FLOW_CONTROL != 0u)) */
                          }
                      }
                      else
                      {   /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
                          rxData = UART_Debug_RXDATA_REG;
                      }
              
                      UART_Debug_EnableRxInt();
              
                  #else
              
                      /* Needs to check status for RX_STS_FIFO_NOTEMPTY bit */
                      rxData = UART_Debug_RXDATA_REG;
              
                  #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
              
                      return(rxData);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_ReadRxStatus
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the current state of the receiver status register and the software
                  *  buffer overflow status.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Current state of the status register.
                  *
                  * Side Effect:
                  *  All status register bits are clear-on-read except
                  *  UART_Debug_RX_STS_FIFO_NOTEMPTY.
                  *  UART_Debug_RX_STS_FIFO_NOTEMPTY clears immediately after RX data
                  *  register read.
                  *
                  * Global Variables:
                  *  UART_Debug_rxBufferOverflow - used to indicate overload condition.
                  *   It set to one in RX interrupt when there isn't free space in
                  *   UART_Debug_rxBufferRead to write new data. This condition returned
                  *   and cleared to zero by this API as an
                  *   UART_Debug_RX_STS_SOFT_BUFF_OVER bit along with RX Status register
                  *   bits.
                  *
                  *******************************************************************************/
                  uint8 UART_Debug_ReadRxStatus(void) 
                  {
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 9   

                      uint8 status;
              
                      status = UART_Debug_RXSTATUS_REG & UART_Debug_RX_HW_MASK;
              
                  #if (UART_Debug_RX_INTERRUPT_ENABLED)
                      if(UART_Debug_rxBufferOverflow != 0u)
                      {
                          status |= UART_Debug_RX_STS_SOFT_BUFF_OVER;
                          UART_Debug_rxBufferOverflow = 0u;
                      }
                  #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
              
                      return(status);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_GetChar
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the last received byte of data. UART_Debug_GetChar() is
                  *  designed for ASCII characters and returns a uint8 where 1 to 255 are values
                  *  for valid characters and 0 indicates an error occurred or no data is present.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  Character read from UART RX buffer. ASCII characters from 1 to 255 are valid.
                  *  A returned zero signifies an error condition or no data available.
                  *
                  * Global Variables:
                  *  UART_Debug_rxBuffer - RAM buffer pointer for save received data.
                  *  UART_Debug_rxBufferWrite - cyclic index for write to rxBuffer,
                  *     checked to identify new data.
                  *  UART_Debug_rxBufferRead - cyclic index for read from rxBuffer,
                  *     incremented after each byte has been read from buffer.
                  *  UART_Debug_rxBufferLoopDetect - cleared if loop condition was detected
                  *     in RX ISR.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint8 UART_Debug_GetChar(void) 
                  {
                      uint8 rxData = 0u;
                      uint8 rxStatus;
              
                  #if (UART_Debug_RX_INTERRUPT_ENABLED)
                      uint8 locRxBufferRead;
                      uint8 locRxBufferWrite;
              
                      /* Protect variables that could change on interrupt */
                      UART_Debug_DisableRxInt();
              
                      locRxBufferRead  = UART_Debug_rxBufferRead;
                      locRxBufferWrite = UART_Debug_rxBufferWrite;
              
                      if( (UART_Debug_rxBufferLoopDetect != 0u) || (locRxBufferRead != locRxBufferWrite) )
                      {
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 10  

                          rxData = UART_Debug_rxBuffer[locRxBufferRead];
                          locRxBufferRead++;
                          if(locRxBufferRead >= UART_Debug_RX_BUFFER_SIZE)
                          {
                              locRxBufferRead = 0u;
                          }
                          /* Update the real pointer */
                          UART_Debug_rxBufferRead = locRxBufferRead;
              
                          if(UART_Debug_rxBufferLoopDetect != 0u)
                          {
                              UART_Debug_rxBufferLoopDetect = 0u;
                              #if( (UART_Debug_RX_INTERRUPT_ENABLED) && (UART_Debug_FLOW_CONTROL != 0u) )
                                  /* When Hardware Flow Control selected - return RX mask */
                                  #if( UART_Debug_HD_ENABLED )
                                      if((UART_Debug_CONTROL_REG & UART_Debug_CTRL_HD_SEND) == 0u)
                                      {   /* In Half duplex mode return RX mask only if
                                          *  RX configuration set, otherwise
                                          *  mask will be returned in LoadRxConfig() API.
                                          */
                                          UART_Debug_RXSTATUS_MASK_REG |= UART_Debug_RX_STS_FIFO_NOTEMPTY;
                                      }
                                  #else
                                      UART_Debug_RXSTATUS_MASK_REG |= UART_Debug_RX_STS_FIFO_NOTEMPTY;
                                  #endif /* end UART_Debug_HD_ENABLED */
                              #endif /* UART_Debug_RX_INTERRUPT_ENABLED and Hardware flow control*/
                          }
              
                      }
                      else
                      {   rxStatus = UART_Debug_RXSTATUS_REG;
                          if((rxStatus & UART_Debug_RX_STS_FIFO_NOTEMPTY) != 0u)
                          {   /* Read received data from FIFO */
                              rxData = UART_Debug_RXDATA_REG;
                              /*Check status on error*/
                              if((rxStatus & (UART_Debug_RX_STS_BREAK | UART_Debug_RX_STS_PAR_ERROR |
                                              UART_Debug_RX_STS_STOP_ERROR | UART_Debug_RX_STS_OVERRUN)) != 0u)
                              {
                                  rxData = 0u;
                              }
                          }
                      }
              
                      UART_Debug_EnableRxInt();
              
                  #else
              
                      rxStatus =UART_Debug_RXSTATUS_REG;
                      if((rxStatus & UART_Debug_RX_STS_FIFO_NOTEMPTY) != 0u)
                      {
                          /* Read received data from FIFO */
                          rxData = UART_Debug_RXDATA_REG;
              
                          /*Check status on error*/
                          if((rxStatus & (UART_Debug_RX_STS_BREAK | UART_Debug_RX_STS_PAR_ERROR |
                                          UART_Debug_RX_STS_STOP_ERROR | UART_Debug_RX_STS_OVERRUN)) != 0u)
                          {
                              rxData = 0u;
                          }
                      }
                  #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
              
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 11  

                      return(rxData);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_GetByte
                  ********************************************************************************
                  *
                  * Summary:
                  *  Reads UART RX buffer immediately, returns received character and error
                  *  condition.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  MSB contains status and LSB contains UART RX data. If the MSB is nonzero,
                  *  an error has occurred.
                  *
                  * Reentrant:
                  *  No.
                  *
                  *******************************************************************************/
                  uint16 UART_Debug_GetByte(void) 
                  {
                      
                  #if (UART_Debug_RX_INTERRUPT_ENABLED)
                      uint16 locErrorStatus;
                      /* Protect variables that could change on interrupt */
                      UART_Debug_DisableRxInt();
                      locErrorStatus = (uint16)UART_Debug_errorStatus;
                      UART_Debug_errorStatus = 0u;
                      UART_Debug_EnableRxInt();
                      return ( (uint16)(locErrorStatus << 8u) | UART_Debug_ReadRxData() );
                  #else
                      return ( ((uint16)UART_Debug_ReadRxStatus() << 8u) | UART_Debug_ReadRxData() );
                  #endif /* UART_Debug_RX_INTERRUPT_ENABLED */
                      
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_GetRxBufferSize
                  ********************************************************************************
                  *
                  * Summary:
                  *  Returns the number of received bytes available in the RX buffer.
                  *  * RX software buffer is disabled (RX Buffer Size parameter is equal to 4): 
                  *    returns 0 for empty RX FIFO or 1 for not empty RX FIFO.
                  *  * RX software buffer is enabled: returns the number of bytes available in 
                  *    the RX software buffer. Bytes available in the RX FIFO do not take to 
                  *    account.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  uint8: Number of bytes in the RX buffer. 
                  *    Return value type depends on RX Buffer Size parameter.
                  *
                  * Global Variables:
                  *  UART_Debug_rxBufferWrite - used to calculate left bytes.
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 12  

                  *  UART_Debug_rxBufferRead - used to calculate left bytes.
                  *  UART_Debug_rxBufferLoopDetect - checked to decide left bytes amount.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Allows the user to find out how full the RX Buffer is.
                  *
                  *******************************************************************************/
                  uint8 UART_Debug_GetRxBufferSize(void)
                                                                          
                  {
                      uint8 size;
              
                  #if (UART_Debug_RX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt */
                      UART_Debug_DisableRxInt();
              
                      if(UART_Debug_rxBufferRead == UART_Debug_rxBufferWrite)
                      {
                          if(UART_Debug_rxBufferLoopDetect != 0u)
                          {
                              size = UART_Debug_RX_BUFFER_SIZE;
                          }
                          else
                          {
                              size = 0u;
                          }
                      }
                      else if(UART_Debug_rxBufferRead < UART_Debug_rxBufferWrite)
                      {
                          size = (UART_Debug_rxBufferWrite - UART_Debug_rxBufferRead);
                      }
                      else
                      {
                          size = (UART_Debug_RX_BUFFER_SIZE - UART_Debug_rxBufferRead) + UART_Debug_rxBufferWrite;
                      }
              
                      UART_Debug_EnableRxInt();
              
                  #else
              
                      /* We can only know if there is data in the fifo. */
                      size = ((UART_Debug_RXSTATUS_REG & UART_Debug_RX_STS_FIFO_NOTEMPTY) != 0u) ? 1u : 0u;
              
                  #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
              
                      return(size);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_ClearRxBuffer
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the receiver memory buffer and hardware RX FIFO of all received data.
                  *
                  * Parameters:
                  *  None.
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 13  

                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_Debug_rxBufferWrite - cleared to zero.
                  *  UART_Debug_rxBufferRead - cleared to zero.
                  *  UART_Debug_rxBufferLoopDetect - cleared to zero.
                  *  UART_Debug_rxBufferOverflow - cleared to zero.
                  *
                  * Reentrant:
                  *  No.
                  *
                  * Theory:
                  *  Setting the pointers to zero makes the system believe there is no data to
                  *  read and writing will resume at address 0 overwriting any data that may
                  *  have remained in the RAM.
                  *
                  * Side Effects:
                  *  Any received data not read from the RAM or FIFO buffer will be lost.
                  *
                  *******************************************************************************/
                  void UART_Debug_ClearRxBuffer(void) 
                  {
                      uint8 enableInterrupts;
              
                      /* Clear the HW FIFO */
                      enableInterrupts = CyEnterCriticalSection();
                      UART_Debug_RXDATA_AUX_CTL_REG |= (uint8)  UART_Debug_RX_FIFO_CLR;
                      UART_Debug_RXDATA_AUX_CTL_REG &= (uint8) ~UART_Debug_RX_FIFO_CLR;
                      CyExitCriticalSection(enableInterrupts);
              
                  #if (UART_Debug_RX_INTERRUPT_ENABLED)
              
                      /* Protect variables that could change on interrupt. */
                      UART_Debug_DisableRxInt();
              
                      UART_Debug_rxBufferRead = 0u;
                      UART_Debug_rxBufferWrite = 0u;
                      UART_Debug_rxBufferLoopDetect = 0u;
                      UART_Debug_rxBufferOverflow = 0u;
              
                      UART_Debug_EnableRxInt();
              
                  #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
              
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_SetRxAddressMode
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the software controlled Addressing mode used by the RX portion of the
                  *  UART.
                  *
                  * Parameters:
                  *  addressMode: Enumerated value indicating the mode of RX addressing
                  *  UART_Debug__B_UART__AM_SW_BYTE_BYTE -  Software Byte-by-Byte address
                  *                                               detection
                  *  UART_Debug__B_UART__AM_SW_DETECT_TO_BUFFER - Software Detect to Buffer
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 14  

                  *                                               address detection
                  *  UART_Debug__B_UART__AM_HW_BYTE_BY_BYTE - Hardware Byte-by-Byte address
                  *                                               detection
                  *  UART_Debug__B_UART__AM_HW_DETECT_TO_BUFFER - Hardware Detect to Buffer
                  *                                               address detection
                  *  UART_Debug__B_UART__AM_NONE - No address detection
                  *
                  * Return:
                  *  None.
                  *
                  * Global Variables:
                  *  UART_Debug_rxAddressMode - the parameter stored in this variable for
                  *   the farther usage in RX ISR.
                  *  UART_Debug_rxAddressDetected - set to initial state (0).
                  *
                  *******************************************************************************/
                  void UART_Debug_SetRxAddressMode(uint8 addressMode)
                                                                      
                  {
                      #if(UART_Debug_RXHW_ADDRESS_ENABLED)
                          #if(UART_Debug_CONTROL_REG_REMOVED)
                              if(0u != addressMode)
                              {
                                  /* Suppress compiler warning */
                              }
                          #else /* UART_Debug_CONTROL_REG_REMOVED */
                              uint8 tmpCtrl;
                              tmpCtrl = UART_Debug_CONTROL_REG & (uint8)~UART_Debug_CTRL_RXADDR_MODE_MASK;
                              tmpCtrl |= (uint8)(addressMode << UART_Debug_CTRL_RXADDR_MODE0_SHIFT);
                              UART_Debug_CONTROL_REG = tmpCtrl;
              
                              #if(UART_Debug_RX_INTERRUPT_ENABLED && \
                                 (UART_Debug_RXBUFFERSIZE > UART_Debug_FIFO_LENGTH) )
                                  UART_Debug_rxAddressMode = addressMode;
                                  UART_Debug_rxAddressDetected = 0u;
                              #endif /* End UART_Debug_RXBUFFERSIZE > UART_Debug_FIFO_LENGTH*/
                          #endif /* End UART_Debug_CONTROL_REG_REMOVED */
                      #else /* UART_Debug_RXHW_ADDRESS_ENABLED */
                          if(0u != addressMode)
                          {
                              /* Suppress compiler warning */
                          }
                      #endif /* End UART_Debug_RXHW_ADDRESS_ENABLED */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_SetRxAddress1
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the first of two hardware-detectable receiver addresses.
                  *
                  * Parameters:
                  *  address: Address #1 for hardware address detection.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void UART_Debug_SetRxAddress1(uint8 address) 
                  {
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 15  

                      UART_Debug_RXADDRESS1_REG = address;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_SetRxAddress2
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the second of two hardware-detectable receiver addresses.
                  *
                  * Parameters:
                  *  address: Address #2 for hardware address detection.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void UART_Debug_SetRxAddress2(uint8 address) 
                  {
                      UART_Debug_RXADDRESS2_REG = address;
                  }
              
              #endif  /* UART_Debug_RX_ENABLED || UART_Debug_HD_ENABLED*/
 883          
 884          
 885          #if( (UART_Debug_TX_ENABLED) || (UART_Debug_HD_ENABLED) )
 886              /*******************************************************************************
 887              * Function Name: UART_Debug_SetTxInterruptMode
 888              ********************************************************************************
 889              *
 890              * Summary:
 891              *  Configures the TX interrupt sources to be enabled, but does not enable the
 892              *  interrupt.
 893              *
 894              * Parameters:
 895              *  intSrc: Bit field containing the TX interrupt sources to enable
 896              *   UART_Debug_TX_STS_COMPLETE        Interrupt on TX byte complete
 897              *   UART_Debug_TX_STS_FIFO_EMPTY      Interrupt when TX FIFO is empty
 898              *   UART_Debug_TX_STS_FIFO_FULL       Interrupt when TX FIFO is full
 899              *   UART_Debug_TX_STS_FIFO_NOT_FULL   Interrupt when TX FIFO is not full
 900              *
 901              * Return:
 902              *  None.
 903              *
 904              * Theory:
 905              *  Enables the output of specific status bits to the interrupt controller
 906              *
 907              *******************************************************************************/
 908              void UART_Debug_SetTxInterruptMode(uint8 intSrc) 
 909              {
 910   1              UART_Debug_TXSTATUS_MASK_REG = intSrc;
 911   1          }
 912          
 913          
 914              /*******************************************************************************
 915              * Function Name: UART_Debug_WriteTxData
 916              ********************************************************************************
 917              *
 918              * Summary:
 919              *  Places a byte of data into the transmit buffer to be sent when the bus is
 920              *  available without checking the TX status register. You must check status
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 16  

 921              *  separately.
 922              *
 923              * Parameters:
 924              *  txDataByte: data byte
 925              *
 926              * Return:
 927              * None.
 928              *
 929              * Global Variables:
 930              *  UART_Debug_txBuffer - RAM buffer pointer for save data for transmission
 931              *  UART_Debug_txBufferWrite - cyclic index for write to txBuffer,
 932              *    incremented after each byte saved to buffer.
 933              *  UART_Debug_txBufferRead - cyclic index for read from txBuffer,
 934              *    checked to identify the condition to write to FIFO directly or to TX buffer
 935              *  UART_Debug_initVar - checked to identify that the component has been
 936              *    initialized.
 937              *
 938              * Reentrant:
 939              *  No.
 940              *
 941              *******************************************************************************/
 942              void UART_Debug_WriteTxData(uint8 txDataByte) 
 943              {
 944   1              /* If not Initialized then skip this function*/
 945   1              if(UART_Debug_initVar != 0u)
 946   1              {
 947   2              #if (UART_Debug_TX_INTERRUPT_ENABLED)
 948   2      
 949   2                  /* Protect variables that could change on interrupt. */
 950   2                  UART_Debug_DisableTxInt();
 951   2      
 952   2                  if( (UART_Debug_txBufferRead == UART_Debug_txBufferWrite) &&
 953   2                      ((UART_Debug_TXSTATUS_REG & UART_Debug_TX_STS_FIFO_FULL) == 0u) )
 954   2                  {
 955   3                      /* Add directly to the FIFO. */
 956   3                      UART_Debug_TXDATA_REG = txDataByte;
 957   3                  }
 958   2                  else
 959   2                  {
 960   3                      if(UART_Debug_txBufferWrite >= UART_Debug_TX_BUFFER_SIZE)
 961   3                      {
 962   4                          UART_Debug_txBufferWrite = 0u;
 963   4                      }
 964   3      
 965   3                      UART_Debug_txBuffer[UART_Debug_txBufferWrite] = txDataByte;
 966   3      
 967   3                      /* Add to the software buffer. */
 968   3                      UART_Debug_txBufferWrite++;
 969   3                  }
 970   2      
 971   2                  UART_Debug_EnableTxInt();
 972   2      
 973   2              #else
              
                          /* Add directly to the FIFO. */
                          UART_Debug_TXDATA_REG = txDataByte;
              
                      #endif /*(UART_Debug_TX_INTERRUPT_ENABLED) */
 979   2              }
 980   1          }
 981          
 982          
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 17  

 983              /*******************************************************************************
 984              * Function Name: UART_Debug_ReadTxStatus
 985              ********************************************************************************
 986              *
 987              * Summary:
 988              *  Reads the status register for the TX portion of the UART.
 989              *
 990              * Parameters:
 991              *  None.
 992              *
 993              * Return:
 994              *  Contents of the status register
 995              *
 996              * Theory:
 997              *  This function reads the TX status register, which is cleared on read.
 998              *  It is up to the user to handle all bits in this return value accordingly,
 999              *  even if the bit was not enabled as an interrupt source the event happened
1000              *  and must be handled accordingly.
1001              *
1002              *******************************************************************************/
1003              uint8 UART_Debug_ReadTxStatus(void) 
1004              {
1005   1              return(UART_Debug_TXSTATUS_REG);
1006   1          }
1007          
1008          
1009              /*******************************************************************************
1010              * Function Name: UART_Debug_PutChar
1011              ********************************************************************************
1012              *
1013              * Summary:
1014              *  Puts a byte of data into the transmit buffer to be sent when the bus is
1015              *  available. This is a blocking API that waits until the TX buffer has room to
1016              *  hold the data.
1017              *
1018              * Parameters:
1019              *  txDataByte: Byte containing the data to transmit
1020              *
1021              * Return:
1022              *  None.
1023              *
1024              * Global Variables:
1025              *  UART_Debug_txBuffer - RAM buffer pointer for save data for transmission
1026              *  UART_Debug_txBufferWrite - cyclic index for write to txBuffer,
1027              *     checked to identify free space in txBuffer and incremented after each byte
1028              *     saved to buffer.
1029              *  UART_Debug_txBufferRead - cyclic index for read from txBuffer,
1030              *     checked to identify free space in txBuffer.
1031              *  UART_Debug_initVar - checked to identify that the component has been
1032              *     initialized.
1033              *
1034              * Reentrant:
1035              *  No.
1036              *
1037              * Theory:
1038              *  Allows the user to transmit any byte of data in a single transfer
1039              *
1040              *******************************************************************************/
1041              void UART_Debug_PutChar(uint8 txDataByte) 
1042              {
1043   1          #if (UART_Debug_TX_INTERRUPT_ENABLED)
1044   1              /* The temporary output pointer is used since it takes two instructions
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 18  

1045   1              *  to increment with a wrap, and we can't risk doing that with the real
1046   1              *  pointer and getting an interrupt in between instructions.
1047   1              */
1048   1              uint8 locTxBufferWrite;
1049   1              uint8 locTxBufferRead;
1050   1      
1051   1              do
1052   1              { /* Block if software buffer is full, so we don't overwrite. */
1053   2      
1054   2              #if ((UART_Debug_TX_BUFFER_SIZE > UART_Debug_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Disable TX interrupt to protect variables from modification */
                          UART_Debug_DisableTxInt();
                      #endif /* (UART_Debug_TX_BUFFER_SIZE > UART_Debug_MAX_BYTE_VALUE) && (CY_PSOC3) */
1058   2      
1059   2                  locTxBufferWrite = UART_Debug_txBufferWrite;
1060   2                  locTxBufferRead  = UART_Debug_txBufferRead;
1061   2      
1062   2              #if ((UART_Debug_TX_BUFFER_SIZE > UART_Debug_MAX_BYTE_VALUE) && (CY_PSOC3))
                          /* Enable interrupt to continue transmission */
                          UART_Debug_EnableTxInt();
                      #endif /* (UART_Debug_TX_BUFFER_SIZE > UART_Debug_MAX_BYTE_VALUE) && (CY_PSOC3) */
1066   2              }
1067   1              while( (locTxBufferWrite < locTxBufferRead) ? (locTxBufferWrite == (locTxBufferRead - 1u)) :
1068   1                                      ((locTxBufferWrite - locTxBufferRead) ==
1069   1                                      (uint8)(UART_Debug_TX_BUFFER_SIZE - 1u)) );
1070   1      
1071   1              if( (locTxBufferRead == locTxBufferWrite) &&
1072   1                  ((UART_Debug_TXSTATUS_REG & UART_Debug_TX_STS_FIFO_FULL) == 0u) )
1073   1              {
1074   2                  /* Add directly to the FIFO */
1075   2                  UART_Debug_TXDATA_REG = txDataByte;
1076   2              }
1077   1              else
1078   1              {
1079   2                  if(locTxBufferWrite >= UART_Debug_TX_BUFFER_SIZE)
1080   2                  {
1081   3                      locTxBufferWrite = 0u;
1082   3                  }
1083   2                  /* Add to the software buffer. */
1084   2                  UART_Debug_txBuffer[locTxBufferWrite] = txDataByte;
1085   2                  locTxBufferWrite++;
1086   2      
1087   2                  /* Finally, update the real output pointer */
1088   2              #if ((UART_Debug_TX_BUFFER_SIZE > UART_Debug_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_Debug_DisableTxInt();
                      #endif /* (UART_Debug_TX_BUFFER_SIZE > UART_Debug_MAX_BYTE_VALUE) && (CY_PSOC3) */
1091   2      
1092   2                  UART_Debug_txBufferWrite = locTxBufferWrite;
1093   2      
1094   2              #if ((UART_Debug_TX_BUFFER_SIZE > UART_Debug_MAX_BYTE_VALUE) && (CY_PSOC3))
                          UART_Debug_EnableTxInt();
                      #endif /* (UART_Debug_TX_BUFFER_SIZE > UART_Debug_MAX_BYTE_VALUE) && (CY_PSOC3) */
1097   2      
1098   2                  if(0u != (UART_Debug_TXSTATUS_REG & UART_Debug_TX_STS_FIFO_EMPTY))
1099   2                  {
1100   3                      /* Trigger TX interrupt to send software buffer */
1101   3                      UART_Debug_SetPendingTxInt();
1102   3                  }
1103   2              }
1104   1      
1105   1          #else
              
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 19  

                      while((UART_Debug_TXSTATUS_REG & UART_Debug_TX_STS_FIFO_FULL) != 0u)
                      {
                          /* Wait for room in the FIFO */
                      }
              
                      /* Add directly to the FIFO */
                      UART_Debug_TXDATA_REG = txDataByte;
              
                  #endif /* UART_Debug_TX_INTERRUPT_ENABLED */
1116   1          }
1117          
1118          
1119              /*******************************************************************************
1120              * Function Name: UART_Debug_PutString
1121              ********************************************************************************
1122              *
1123              * Summary:
1124              *  Sends a NULL terminated string to the TX buffer for transmission.
1125              *
1126              * Parameters:
1127              *  string[]: Pointer to the null terminated string array residing in RAM or ROM
1128              *
1129              * Return:
1130              *  None.
1131              *
1132              * Global Variables:
1133              *  UART_Debug_initVar - checked to identify that the component has been
1134              *     initialized.
1135              *
1136              * Reentrant:
1137              *  No.
1138              *
1139              * Theory:
1140              *  If there is not enough memory in the TX buffer for the entire string, this
1141              *  function blocks until the last character of the string is loaded into the
1142              *  TX buffer.
1143              *
1144              *******************************************************************************/
1145              void UART_Debug_PutString(const char8 string[]) 
1146              {
1147   1              uint16 bufIndex = 0u;
1148   1      
1149   1              /* If not Initialized then skip this function */
1150   1              if(UART_Debug_initVar != 0u)
1151   1              {
1152   2                  /* This is a blocking function, it will not exit until all data is sent */
1153   2                  while(string[bufIndex] != (char8) 0)
1154   2                  {
1155   3                      UART_Debug_PutChar((uint8)string[bufIndex]);
1156   3                      bufIndex++;
1157   3                  }
1158   2              }
1159   1          }
1160          
1161          
1162              /*******************************************************************************
1163              * Function Name: UART_Debug_PutArray
1164              ********************************************************************************
1165              *
1166              * Summary:
1167              *  Places N bytes of data from a memory array into the TX buffer for
1168              *  transmission.
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 20  

1169              *
1170              * Parameters:
1171              *  string[]: Address of the memory array residing in RAM or ROM.
1172              *  byteCount: Number of bytes to be transmitted. The type depends on TX Buffer
1173              *             Size parameter.
1174              *
1175              * Return:
1176              *  None.
1177              *
1178              * Global Variables:
1179              *  UART_Debug_initVar - checked to identify that the component has been
1180              *     initialized.
1181              *
1182              * Reentrant:
1183              *  No.
1184              *
1185              * Theory:
1186              *  If there is not enough memory in the TX buffer for the entire string, this
1187              *  function blocks until the last character of the string is loaded into the
1188              *  TX buffer.
1189              *
1190              *******************************************************************************/
1191              void UART_Debug_PutArray(const uint8 string[], uint8 byteCount)
1192                                                                              
1193              {
1194   1              uint8 bufIndex = 0u;
1195   1      
1196   1              /* If not Initialized then skip this function */
1197   1              if(UART_Debug_initVar != 0u)
1198   1              {
1199   2                  while(bufIndex < byteCount)
1200   2                  {
1201   3                      UART_Debug_PutChar(string[bufIndex]);
1202   3                      bufIndex++;
1203   3                  }
1204   2              }
1205   1          }
1206          
1207          
1208              /*******************************************************************************
1209              * Function Name: UART_Debug_PutCRLF
1210              ********************************************************************************
1211              *
1212              * Summary:
1213              *  Writes a byte of data followed by a carriage return (0x0D) and line feed
1214              *  (0x0A) to the transmit buffer.
1215              *
1216              * Parameters:
1217              *  txDataByte: Data byte to transmit before the carriage return and line feed.
1218              *
1219              * Return:
1220              *  None.
1221              *
1222              * Global Variables:
1223              *  UART_Debug_initVar - checked to identify that the component has been
1224              *     initialized.
1225              *
1226              * Reentrant:
1227              *  No.
1228              *
1229              *******************************************************************************/
1230              void UART_Debug_PutCRLF(uint8 txDataByte) 
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 21  

1231              {
1232   1              /* If not Initialized then skip this function */
1233   1              if(UART_Debug_initVar != 0u)
1234   1              {
1235   2                  UART_Debug_PutChar(txDataByte);
1236   2                  UART_Debug_PutChar(0x0Du);
1237   2                  UART_Debug_PutChar(0x0Au);
1238   2              }
1239   1          }
1240          
1241          
1242              /*******************************************************************************
1243              * Function Name: UART_Debug_GetTxBufferSize
1244              ********************************************************************************
1245              *
1246              * Summary:
1247              *  Returns the number of bytes in the TX buffer which are waiting to be 
1248              *  transmitted.
1249              *  * TX software buffer is disabled (TX Buffer Size parameter is equal to 4): 
1250              *    returns 0 for empty TX FIFO, 1 for not full TX FIFO or 4 for full TX FIFO.
1251              *  * TX software buffer is enabled: returns the number of bytes in the TX 
1252              *    software buffer which are waiting to be transmitted. Bytes available in the
1253              *    TX FIFO do not count.
1254              *
1255              * Parameters:
1256              *  None.
1257              *
1258              * Return:
1259              *  Number of bytes used in the TX buffer. Return value type depends on the TX 
1260              *  Buffer Size parameter.
1261              *
1262              * Global Variables:
1263              *  UART_Debug_txBufferWrite - used to calculate left space.
1264              *  UART_Debug_txBufferRead - used to calculate left space.
1265              *
1266              * Reentrant:
1267              *  No.
1268              *
1269              * Theory:
1270              *  Allows the user to find out how full the TX Buffer is.
1271              *
1272              *******************************************************************************/
1273              uint8 UART_Debug_GetTxBufferSize(void)
1274                                                                      
1275              {
1276   1              uint8 size;
1277   1      
1278   1          #if (UART_Debug_TX_INTERRUPT_ENABLED)
1279   1      
1280   1              /* Protect variables that could change on interrupt. */
1281   1              UART_Debug_DisableTxInt();
1282   1      
1283   1              if(UART_Debug_txBufferRead == UART_Debug_txBufferWrite)
1284   1              {
1285   2                  size = 0u;
1286   2              }
1287   1              else if(UART_Debug_txBufferRead < UART_Debug_txBufferWrite)
1288   1              {
1289   2                  size = (UART_Debug_txBufferWrite - UART_Debug_txBufferRead);
1290   2              }
1291   1              else
1292   1              {
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 22  

1293   2                  size = (UART_Debug_TX_BUFFER_SIZE - UART_Debug_txBufferRead) +
1294   2                          UART_Debug_txBufferWrite;
1295   2              }
1296   1      
1297   1              UART_Debug_EnableTxInt();
1298   1      
1299   1          #else
              
                      size = UART_Debug_TXSTATUS_REG;
              
                      /* Is the fifo is full. */
                      if((size & UART_Debug_TX_STS_FIFO_FULL) != 0u)
                      {
                          size = UART_Debug_FIFO_LENGTH;
                      }
                      else if((size & UART_Debug_TX_STS_FIFO_EMPTY) != 0u)
                      {
                          size = 0u;
                      }
                      else
                      {
                          /* We only know there is data in the fifo. */
                          size = 1u;
                      }
              
                  #endif /* (UART_Debug_TX_INTERRUPT_ENABLED) */
1319   1      
1320   1          return(size);
1321   1          }
1322          
1323          
1324              /*******************************************************************************
1325              * Function Name: UART_Debug_ClearTxBuffer
1326              ********************************************************************************
1327              *
1328              * Summary:
1329              *  Clears all data from the TX buffer and hardware TX FIFO.
1330              *
1331              * Parameters:
1332              *  None.
1333              *
1334              * Return:
1335              *  None.
1336              *
1337              * Global Variables:
1338              *  UART_Debug_txBufferWrite - cleared to zero.
1339              *  UART_Debug_txBufferRead - cleared to zero.
1340              *
1341              * Reentrant:
1342              *  No.
1343              *
1344              * Theory:
1345              *  Setting the pointers to zero makes the system believe there is no data to
1346              *  read and writing will resume at address 0 overwriting any data that may have
1347              *  remained in the RAM.
1348              *
1349              * Side Effects:
1350              *  Data waiting in the transmit buffer is not sent; a byte that is currently
1351              *  transmitting finishes transmitting.
1352              *
1353              *******************************************************************************/
1354              void UART_Debug_ClearTxBuffer(void) 
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 23  

1355              {
1356   1              uint8 enableInterrupts;
1357   1      
1358   1              enableInterrupts = CyEnterCriticalSection();
1359   1              /* Clear the HW FIFO */
1360   1              UART_Debug_TXDATA_AUX_CTL_REG |= (uint8)  UART_Debug_TX_FIFO_CLR;
1361   1              UART_Debug_TXDATA_AUX_CTL_REG &= (uint8) ~UART_Debug_TX_FIFO_CLR;
1362   1              CyExitCriticalSection(enableInterrupts);
1363   1      
1364   1          #if (UART_Debug_TX_INTERRUPT_ENABLED)
1365   1      
1366   1              /* Protect variables that could change on interrupt. */
1367   1              UART_Debug_DisableTxInt();
1368   1      
1369   1              UART_Debug_txBufferRead = 0u;
1370   1              UART_Debug_txBufferWrite = 0u;
1371   1      
1372   1              /* Enable Tx interrupt. */
1373   1              UART_Debug_EnableTxInt();
1374   1      
1375   1          #endif /* (UART_Debug_TX_INTERRUPT_ENABLED) */
1376   1          }
1377          
1378          
1379              /*******************************************************************************
1380              * Function Name: UART_Debug_SendBreak
1381              ********************************************************************************
1382              *
1383              * Summary:
1384              *  Transmits a break signal on the bus.
1385              *
1386              * Parameters:
1387              *  uint8 retMode:  Send Break return mode. See the following table for options.
1388              *   UART_Debug_SEND_BREAK - Initialize registers for break, send the Break
1389              *       signal and return immediately.
1390              *   UART_Debug_WAIT_FOR_COMPLETE_REINIT - Wait until break transmission is
1391              *       complete, reinitialize registers to normal transmission mode then return
1392              *   UART_Debug_REINIT - Reinitialize registers to normal transmission mode
1393              *       then return.
1394              *   UART_Debug_SEND_WAIT_REINIT - Performs both options: 
1395              *      UART_Debug_SEND_BREAK and UART_Debug_WAIT_FOR_COMPLETE_REINIT.
1396              *      This option is recommended for most cases.
1397              *
1398              * Return:
1399              *  None.
1400              *
1401              * Global Variables:
1402              *  UART_Debug_initVar - checked to identify that the component has been
1403              *     initialized.
1404              *  txPeriod - static variable, used for keeping TX period configuration.
1405              *
1406              * Reentrant:
1407              *  No.
1408              *
1409              * Theory:
1410              *  SendBreak function initializes registers to send 13-bit break signal. It is
1411              *  important to return the registers configuration to normal for continue 8-bit
1412              *  operation.
1413              *  There are 3 variants for this API usage:
1414              *  1) SendBreak(3) - function will send the Break signal and take care on the
1415              *     configuration returning. Function will block CPU until transmission
1416              *     complete.
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 24  

1417              *  2) User may want to use blocking time if UART configured to the low speed
1418              *     operation
1419              *     Example for this case:
1420              *     SendBreak(0);     - initialize Break signal transmission
1421              *         Add your code here to use CPU time
1422              *     SendBreak(1);     - complete Break operation
1423              *  3) Same to 2) but user may want to initialize and use the interrupt to
1424              *     complete break operation.
1425              *     Example for this case:
1426              *     Initialize TX interrupt with "TX - On TX Complete" parameter
1427              *     SendBreak(0);     - initialize Break signal transmission
1428              *         Add your code here to use CPU time
1429              *     When interrupt appear with UART_Debug_TX_STS_COMPLETE status:
1430              *     SendBreak(2);     - complete Break operation
1431              *
1432              * Side Effects:
1433              *  The UART_Debug_SendBreak() function initializes registers to send a
1434              *  break signal.
1435              *  Break signal length depends on the break signal bits configuration.
1436              *  The register configuration should be reinitialized before normal 8-bit
1437              *  communication can continue.
1438              *
1439              *******************************************************************************/
1440              void UART_Debug_SendBreak(uint8 retMode) 
1441              {
1442   1      
1443   1              /* If not Initialized then skip this function*/
1444   1              if(UART_Debug_initVar != 0u)
1445   1              {
1446   2                  /* Set the Counter to 13-bits and transmit a 00 byte */
1447   2                  /* When that is done then reset the counter value back */
1448   2                  uint8 tmpStat;
1449   2      
1450   2              #if(UART_Debug_HD_ENABLED) /* Half Duplex mode*/
              
                          if( (retMode == UART_Debug_SEND_BREAK) ||
                              (retMode == UART_Debug_SEND_WAIT_REINIT ) )
                          {
                              /* CTRL_HD_SEND_BREAK - sends break bits in HD mode */
                              UART_Debug_WriteControlRegister(UART_Debug_ReadControlRegister() |
                                                                    UART_Debug_CTRL_HD_SEND_BREAK);
                              /* Send zeros */
                              UART_Debug_TXDATA_REG = 0u;
              
                              do /* Wait until transmit starts */
                              {
                                  tmpStat = UART_Debug_TXSTATUS_REG;
                              }
                              while((tmpStat & UART_Debug_TX_STS_FIFO_EMPTY) != 0u);
                          }
              
                          if( (retMode == UART_Debug_WAIT_FOR_COMPLETE_REINIT) ||
                              (retMode == UART_Debug_SEND_WAIT_REINIT) )
                          {
                              do /* Wait until transmit complete */
                              {
                                  tmpStat = UART_Debug_TXSTATUS_REG;
                              }
                              while(((uint8)~tmpStat & UART_Debug_TX_STS_COMPLETE) != 0u);
                          }
              
                          if( (retMode == UART_Debug_WAIT_FOR_COMPLETE_REINIT) ||
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 25  

                              (retMode == UART_Debug_REINIT) ||
                              (retMode == UART_Debug_SEND_WAIT_REINIT) )
                          {
                              UART_Debug_WriteControlRegister(UART_Debug_ReadControlRegister() &
                                                            (uint8)~UART_Debug_CTRL_HD_SEND_BREAK);
                          }
              
                      #else /* UART_Debug_HD_ENABLED Full Duplex mode */
1487   2      
1488   2                  static uint8 txPeriod;
1489   2      
1490   2                  if( (retMode == UART_Debug_SEND_BREAK) ||
1491   2                      (retMode == UART_Debug_SEND_WAIT_REINIT) )
1492   2                  {
1493   3                      /* CTRL_HD_SEND_BREAK - skip to send parity bit at Break signal in Full Duplex mode */
1494   3                      #if( (UART_Debug_PARITY_TYPE != UART_Debug__B_UART__NONE_REVB) || \
1495   3                                          (UART_Debug_PARITY_TYPE_SW != 0u) )
                                  UART_Debug_WriteControlRegister(UART_Debug_ReadControlRegister() |
                                                                        UART_Debug_CTRL_HD_SEND_BREAK);
                              #endif /* End UART_Debug_PARITY_TYPE != UART_Debug__B_UART__NONE_REVB  */
1499   3      
1500   3                      #if(UART_Debug_TXCLKGEN_DP)
1501   3                          txPeriod = UART_Debug_TXBITCLKTX_COMPLETE_REG;
1502   3                          UART_Debug_TXBITCLKTX_COMPLETE_REG = UART_Debug_TXBITCTR_BREAKBITS;
1503   3                      #else
                                  txPeriod = UART_Debug_TXBITCTR_PERIOD_REG;
                                  UART_Debug_TXBITCTR_PERIOD_REG = UART_Debug_TXBITCTR_BREAKBITS8X;
                              #endif /* End UART_Debug_TXCLKGEN_DP */
1507   3      
1508   3                      /* Send zeros */
1509   3                      UART_Debug_TXDATA_REG = 0u;
1510   3      
1511   3                      do /* Wait until transmit starts */
1512   3                      {
1513   4                          tmpStat = UART_Debug_TXSTATUS_REG;
1514   4                      }
1515   3                      while((tmpStat & UART_Debug_TX_STS_FIFO_EMPTY) != 0u);
1516   3                  }
1517   2      
1518   2                  if( (retMode == UART_Debug_WAIT_FOR_COMPLETE_REINIT) ||
1519   2                      (retMode == UART_Debug_SEND_WAIT_REINIT) )
1520   2                  {
1521   3                      do /* Wait until transmit complete */
1522   3                      {
1523   4                          tmpStat = UART_Debug_TXSTATUS_REG;
1524   4                      }
1525   3                      while(((uint8)~tmpStat & UART_Debug_TX_STS_COMPLETE) != 0u);
1526   3                  }
1527   2      
1528   2                  if( (retMode == UART_Debug_WAIT_FOR_COMPLETE_REINIT) ||
1529   2                      (retMode == UART_Debug_REINIT) ||
1530   2                      (retMode == UART_Debug_SEND_WAIT_REINIT) )
1531   2                  {
1532   3      
1533   3                  #if(UART_Debug_TXCLKGEN_DP)
1534   3                      UART_Debug_TXBITCLKTX_COMPLETE_REG = txPeriod;
1535   3                  #else
                              UART_Debug_TXBITCTR_PERIOD_REG = txPeriod;
                          #endif /* End UART_Debug_TXCLKGEN_DP */
1538   3      
1539   3                  #if( (UART_Debug_PARITY_TYPE != UART_Debug__B_UART__NONE_REVB) || \
1540   3                       (UART_Debug_PARITY_TYPE_SW != 0u) )
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 26  

                              UART_Debug_WriteControlRegister(UART_Debug_ReadControlRegister() &
                                                                    (uint8) ~UART_Debug_CTRL_HD_SEND_BREAK);
                          #endif /* End UART_Debug_PARITY_TYPE != NONE */
1544   3                  }
1545   2              #endif    /* End UART_Debug_HD_ENABLED */
1546   2              }
1547   1          }
1548          
1549          
1550              /*******************************************************************************
1551              * Function Name: UART_Debug_SetTxAddressMode
1552              ********************************************************************************
1553              *
1554              * Summary:
1555              *  Configures the transmitter to signal the next bytes is address or data.
1556              *
1557              * Parameters:
1558              *  addressMode: 
1559              *       UART_Debug_SET_SPACE - Configure the transmitter to send the next
1560              *                                    byte as a data.
1561              *       UART_Debug_SET_MARK  - Configure the transmitter to send the next
1562              *                                    byte as an address.
1563              *
1564              * Return:
1565              *  None.
1566              *
1567              * Side Effects:
1568              *  This function sets and clears UART_Debug_CTRL_MARK bit in the Control
1569              *  register.
1570              *
1571              *******************************************************************************/
1572              void UART_Debug_SetTxAddressMode(uint8 addressMode) 
1573              {
1574   1              /* Mark/Space sending enable */
1575   1              if(addressMode != 0u)
1576   1              {
1577   2              #if( UART_Debug_CONTROL_REG_REMOVED == 0u )
                          UART_Debug_WriteControlRegister(UART_Debug_ReadControlRegister() |
                                                                UART_Debug_CTRL_MARK);
                      #endif /* End UART_Debug_CONTROL_REG_REMOVED == 0u */
1581   2              }
1582   1              else
1583   1              {
1584   2              #if( UART_Debug_CONTROL_REG_REMOVED == 0u )
                          UART_Debug_WriteControlRegister(UART_Debug_ReadControlRegister() &
                                                                (uint8) ~UART_Debug_CTRL_MARK);
                      #endif /* End UART_Debug_CONTROL_REG_REMOVED == 0u */
1588   2              }
1589   1          }
1590          
1591          #endif  /* EndUART_Debug_TX_ENABLED */
1592          
1593          #if(UART_Debug_HD_ENABLED)
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_LoadRxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the receiver configuration in half duplex mode. After calling this
                  *  function, the UART is ready to receive data.
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 27  

                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the transmitter
                  *  configuration.
                  *
                  *******************************************************************************/
                  void UART_Debug_LoadRxConfig(void) 
                  {
                      UART_Debug_WriteControlRegister(UART_Debug_ReadControlRegister() &
                                                              (uint8)~UART_Debug_CTRL_HD_SEND);
                      UART_Debug_RXBITCTR_PERIOD_REG = UART_Debug_HD_RXBITCTR_INIT;
              
                  #if (UART_Debug_RX_INTERRUPT_ENABLED)
                      /* Enable RX interrupt after set RX configuration */
                      UART_Debug_SetRxInterruptMode(UART_Debug_INIT_RX_INTERRUPTS_MASK);
                  #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
                  }
              
              
                  /*******************************************************************************
                  * Function Name: UART_Debug_LoadTxConfig
                  ********************************************************************************
                  *
                  * Summary:
                  *  Loads the transmitter configuration in half duplex mode. After calling this
                  *  function, the UART is ready to transmit data.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  * Side Effects:
                  *  Valid only in half duplex mode. You must make sure that the previous
                  *  transaction is complete and it is safe to unload the receiver configuration.
                  *
                  *******************************************************************************/
                  void UART_Debug_LoadTxConfig(void) 
                  {
                  #if (UART_Debug_RX_INTERRUPT_ENABLED)
                      /* Disable RX interrupts before set TX configuration */
                      UART_Debug_SetRxInterruptMode(0u);
                  #endif /* (UART_Debug_RX_INTERRUPT_ENABLED) */
              
                      UART_Debug_WriteControlRegister(UART_Debug_ReadControlRegister() | UART_Debug_CTRL_HD_SEND);
                      UART_Debug_RXBITCTR_PERIOD_REG = UART_Debug_HD_TXBITCTR_INIT;
                  }
              
              #endif  /* UART_Debug_HD_ENABLED */
1660          
1661          
1662          /* [] END OF FILE */
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 28  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION UART_Debug_Start (BEGIN)
                                           ; SOURCE LINE # 76
                                           ; SOURCE LINE # 77
                                           ; SOURCE LINE # 79
0000 900000      R     MOV     DPTR,#UART_Debug_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0001
                                           ; SOURCE LINE # 80
                                           ; SOURCE LINE # 81
0008 120000      R     LCALL   UART_Debug_Init
                                           ; SOURCE LINE # 82
000B 900000      R     MOV     DPTR,#UART_Debug_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 83
0011         ?C0001:
                                           ; SOURCE LINE # 85
0011 120000      R     LCALL   UART_Debug_Enable
                                           ; SOURCE LINE # 86
0014 22                RET     
             ; FUNCTION UART_Debug_Start (END)

             ; FUNCTION UART_Debug_Init (BEGIN)
                                           ; SOURCE LINE # 106
                                           ; SOURCE LINE # 107
                                           ; SOURCE LINE # 132
0000 7C00        E     MOV     R4,#HIGH UART_Debug_TXISR
0002 7D00        E     MOV     R5,#LOW UART_Debug_TXISR
0004 7F01              MOV     R7,#01H
0006 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 133
0009 7D07              MOV     R5,#07H
000B 7F01              MOV     R7,#01H
000D 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 138
0010 906425            MOV     DPTR,#06425H
0013 7406              MOV     A,#06H
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
0016 906435            MOV     DPTR,#06435H
0019 7447              MOV     A,#047H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 148
001C 906485            MOV     DPTR,#06485H
001F 7402              MOV     A,#02H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
0022 22                RET     
             ; FUNCTION UART_Debug_Init (END)

             ; FUNCTION UART_Debug_Enable (BEGIN)
                                           ; SOURCE LINE # 183
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 186
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 29  

0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 211
0008 906495            MOV     DPTR,#06495H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4410              ORL     A,#010H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 213
0013 9044D8            MOV     DPTR,#044D8H
0016 7402              MOV     A,#02H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 214
0019 9044C0            MOV     DPTR,#044C0H
001C 7402              MOV     A,#02H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 219
001F 120000      E     LCALL   UART_Debug_IntClock_Start
                                           ; SOURCE LINE # 222
0022 900000      R     MOV     DPTR,#enableInterrupts
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 223
002A 22                RET     
             ; FUNCTION UART_Debug_Enable (END)

             ; FUNCTION UART_Debug_Stop (BEGIN)
                                           ; SOURCE LINE # 240
                                           ; SOURCE LINE # 241
                                           ; SOURCE LINE # 243
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 257
0008 120000      E     LCALL   UART_Debug_IntClock_Stop
                                           ; SOURCE LINE # 270
000B 906495            MOV     DPTR,#06495H
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 54EF              ANL     A,#0EFH
0013 FF                MOV     R7,A
0014 EF                MOV     A,R7
0015 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 273
0016 9044C8            MOV     DPTR,#044C8H
0019 7402              MOV     A,#02H
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 277
001C 900000      R     MOV     DPTR,#enableInterrupts
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 278
0024 22                RET     
             ; FUNCTION UART_Debug_Stop (END)

             ; FUNCTION UART_Debug_ReadControlRegister (BEGIN)
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 30  

                                           ; SOURCE LINE # 295
                                           ; SOURCE LINE # 296
                                           ; SOURCE LINE # 298
0000 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 302
0002         ?C0006:
0002 22                RET     
             ; FUNCTION UART_Debug_ReadControlRegister (END)

             ; FUNCTION _UART_Debug_WriteControlRegister (BEGIN)
                                           ; SOURCE LINE # 319
0000 900000      R     MOV     DPTR,#control
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 322
                                           ; SOURCE LINE # 323
                                           ; SOURCE LINE # 325
                                           ; SOURCE LINE # 329
0005         ?C0008:
0005 22                RET     
             ; FUNCTION _UART_Debug_WriteControlRegister (END)

             ; FUNCTION _UART_Debug_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 908
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 909
                                           ; SOURCE LINE # 910
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 906485            MOV     DPTR,#06485H
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 911
000F 22                RET     
             ; FUNCTION _UART_Debug_SetTxInterruptMode (END)

             ; FUNCTION _UART_Debug_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 942
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 943
                                           ; SOURCE LINE # 945
0005 900000      R     MOV     DPTR,#UART_Debug_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 605B              JZ      ?C0014
                                           ; SOURCE LINE # 946
                                           ; SOURCE LINE # 950
000D 9044C8            MOV     DPTR,#044C8H
0010 7402              MOV     A,#02H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 953
0013 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 900000      R     MOV     DPTR,#UART_Debug_txBufferRead
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 31  

001B E0                MOVX    A,@DPTR
001C FE                MOV     R6,A
001D EE                MOV     A,R6
001E B50715            CJNE    A,AR7,?C0011
0021 906465            MOV     DPTR,#06465H
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 EF                MOV     A,R7
0027 20E20C            JB      ACC.2,?C0011
                                           ; SOURCE LINE # 954
                                           ; SOURCE LINE # 956
002A 900000      R     MOV     DPTR,#txDataByte
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F 906446            MOV     DPTR,#06446H
0032 EF                MOV     A,R7
0033 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 957
0034 802C              SJMP    ?C0012
0036         ?C0011:
                                           ; SOURCE LINE # 959
                                           ; SOURCE LINE # 960
0036 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
0039 E0                MOVX    A,@DPTR
003A FF                MOV     R7,A
003B EF                MOV     A,R7
003C C3                CLR     C
003D 9464              SUBB    A,#064H
003F 4005              JC      ?C0013
                                           ; SOURCE LINE # 961
                                           ; SOURCE LINE # 962
0041 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
0044 E4                CLR     A
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 963
0046         ?C0013:
                                           ; SOURCE LINE # 965
0046 900000      R     MOV     DPTR,#txDataByte
0049 E0                MOVX    A,@DPTR
004A FF                MOV     R7,A
004B 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
004E E0                MOVX    A,@DPTR
004F FE                MOV     R6,A
0050 7400        R     MOV     A,#LOW UART_Debug_txBuffer
0052 2E                ADD     A,R6
0053 F582              MOV     DPL,A
0055 E4                CLR     A
0056 3400        R     ADDC    A,#HIGH UART_Debug_txBuffer
0058 F583              MOV     DPH,A
005A EF                MOV     A,R7
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 968
005C 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
005F E0                MOVX    A,@DPTR
0060 04                INC     A
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 969
0062         ?C0012:
                                           ; SOURCE LINE # 971
0062 9044C0            MOV     DPTR,#044C0H
0065 7402              MOV     A,#02H
0067 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 32  

                                           ; SOURCE LINE # 979
                                           ; SOURCE LINE # 980
0068         ?C0014:
0068 22                RET     
             ; FUNCTION _UART_Debug_WriteTxData (END)

             ; FUNCTION UART_Debug_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 1003
                                           ; SOURCE LINE # 1004
                                           ; SOURCE LINE # 1005
0000 906465            MOV     DPTR,#06465H
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1006
0005         ?C0015:
0005 22                RET     
             ; FUNCTION UART_Debug_ReadTxStatus (END)

             ; FUNCTION _UART_Debug_PutChar (BEGIN)
                                           ; SOURCE LINE # 1041
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1042
0005         ?C0018:
                                           ; SOURCE LINE # 1052
                                           ; SOURCE LINE # 1059
0005 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 900000      R     MOV     DPTR,#locTxBufferWrite
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1060
000F 900000      R     MOV     DPTR,#UART_Debug_txBufferRead
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 900000      R     MOV     DPTR,#locTxBufferRead
0017 EF                MOV     A,R7
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1066
                                           ; SOURCE LINE # 1069
0019 900000      R     MOV     DPTR,#locTxBufferRead
001C E0                MOVX    A,@DPTR
001D FF                MOV     R7,A
001E 900000      R     MOV     DPTR,#locTxBufferWrite
0021 E0                MOVX    A,@DPTR
0022 FE                MOV     R6,A
0023 EE                MOV     A,R6
0024 C3                CLR     C
0025 9F                SUBB    A,R7
0026 5026              JNC     ?C0019
0028 900000      R     MOV     DPTR,#locTxBufferRead
002B E0                MOVX    A,@DPTR
002C FF                MOV     R7,A
002D 7E00              MOV     R6,#00H
002F EF                MOV     A,R7
0030 24FF              ADD     A,#0FFH
0032 FF                MOV     R7,A
0033 EE                MOV     A,R6
0034 34FF              ADDC    A,#0FFH
0036 FE                MOV     R6,A
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 33  

0037 900000      R     MOV     DPTR,#locTxBufferWrite
003A E0                MOVX    A,@DPTR
003B FD                MOV     R5,A
003C 7C00              MOV     R4,#00H
003E EF                MOV     A,R7
003F B50508            CJNE    A,AR5,?C0021
0042 EE                MOV     A,R6
0043 B50404            CJNE    A,AR4,?C0021
0046 7F01              MOV     R7,#01H
0048 8002              SJMP    ?C0022
004A         ?C0021:
004A 7F00              MOV     R7,#00H
004C         ?C0022:
004C 8018              SJMP    ?C0020
004E         ?C0019:
004E 900000      R     MOV     DPTR,#locTxBufferRead
0051 E0                MOVX    A,@DPTR
0052 FF                MOV     R7,A
0053 900000      R     MOV     DPTR,#locTxBufferWrite
0056 E0                MOVX    A,@DPTR
0057 FE                MOV     R6,A
0058 C3                CLR     C
0059 EE                MOV     A,R6
005A 9F                SUBB    A,R7
005B FF                MOV     R7,A
005C EF                MOV     A,R7
005D B46304            CJNE    A,#063H,?C0023
0060 7F01              MOV     R7,#01H
0062 8002              SJMP    ?C0024
0064         ?C0023:
0064 7F00              MOV     R7,#00H
0066         ?C0024:
0066         ?C0020:
0066 EF                MOV     A,R7
0067 709C              JNZ     ?C0018
                                           ; SOURCE LINE # 1072
0069 900000      R     MOV     DPTR,#locTxBufferWrite
006C E0                MOVX    A,@DPTR
006D FF                MOV     R7,A
006E 900000      R     MOV     DPTR,#locTxBufferRead
0071 E0                MOVX    A,@DPTR
0072 FE                MOV     R6,A
0073 EE                MOV     A,R6
0074 B50714            CJNE    A,AR7,?C0025
0077 906465            MOV     DPTR,#06465H
007A E0                MOVX    A,@DPTR
007B FF                MOV     R7,A
007C EF                MOV     A,R7
007D 20E20B            JB      ACC.2,?C0025
                                           ; SOURCE LINE # 1073
                                           ; SOURCE LINE # 1075
0080 900000      R     MOV     DPTR,#txDataByte
0083 E0                MOVX    A,@DPTR
0084 FF                MOV     R7,A
0085 906446            MOV     DPTR,#06446H
0088 EF                MOV     A,R7
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1076
008A 22                RET     
008B         ?C0025:
                                           ; SOURCE LINE # 1078
                                           ; SOURCE LINE # 1079
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 34  

008B 900000      R     MOV     DPTR,#locTxBufferWrite
008E E0                MOVX    A,@DPTR
008F FF                MOV     R7,A
0090 EF                MOV     A,R7
0091 C3                CLR     C
0092 9464              SUBB    A,#064H
0094 4005              JC      ?C0027
                                           ; SOURCE LINE # 1080
                                           ; SOURCE LINE # 1081
0096 900000      R     MOV     DPTR,#locTxBufferWrite
0099 E4                CLR     A
009A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1082
009B         ?C0027:
                                           ; SOURCE LINE # 1084
009B 900000      R     MOV     DPTR,#txDataByte
009E E0                MOVX    A,@DPTR
009F FF                MOV     R7,A
00A0 900000      R     MOV     DPTR,#locTxBufferWrite
00A3 E0                MOVX    A,@DPTR
00A4 FE                MOV     R6,A
00A5 7400        R     MOV     A,#LOW UART_Debug_txBuffer
00A7 2E                ADD     A,R6
00A8 F582              MOV     DPL,A
00AA E4                CLR     A
00AB 3400        R     ADDC    A,#HIGH UART_Debug_txBuffer
00AD F583              MOV     DPH,A
00AF EF                MOV     A,R7
00B0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1085
00B1 900000      R     MOV     DPTR,#locTxBufferWrite
00B4 E0                MOVX    A,@DPTR
00B5 04                INC     A
00B6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1092
00B7 900000      R     MOV     DPTR,#locTxBufferWrite
00BA E0                MOVX    A,@DPTR
00BB FF                MOV     R7,A
00BC 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
00BF EF                MOV     A,R7
00C0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1098
00C1 906465            MOV     DPTR,#06465H
00C4 E0                MOVX    A,@DPTR
00C5 FF                MOV     R7,A
00C6 EF                MOV     A,R7
00C7 30E106            JNB     ACC.1,?C0029
                                           ; SOURCE LINE # 1099
                                           ; SOURCE LINE # 1101
00CA 9044D0            MOV     DPTR,#044D0H
00CD 7402              MOV     A,#02H
00CF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1102
                                           ; SOURCE LINE # 1103
                                           ; SOURCE LINE # 1116
00D0         ?C0029:
00D0 22                RET     
             ; FUNCTION _UART_Debug_PutChar (END)

             ; FUNCTION _UART_Debug_PutString (BEGIN)
                                           ; SOURCE LINE # 1145
0000 900000      R     MOV     DPTR,#string
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 35  

0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1146
                                           ; SOURCE LINE # 1147
0006 900000      R     MOV     DPTR,#bufIndex
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C E4                CLR     A
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1150
000E 900000      R     MOV     DPTR,#UART_Debug_initVar
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 EF                MOV     A,R7
0014 6042              JZ      ?C0033
                                           ; SOURCE LINE # 1151
0016         ?C0031:
                                           ; SOURCE LINE # 1153
0016 900000      R     MOV     DPTR,#string
0019 120000      E     LCALL   ?C?PLDXDATA
001C 900000      R     MOV     DPTR,#bufIndex
001F E0                MOVX    A,@DPTR
0020 FE                MOV     R6,A
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E9                MOV     A,R1
0025 2F                ADD     A,R7
0026 F9                MOV     R1,A
0027 EA                MOV     A,R2
0028 3E                ADDC    A,R6
0029 FA                MOV     R2,A
002A 120000      E     LCALL   ?C?CLDPTR
002D FF                MOV     R7,A
002E EF                MOV     A,R7
002F 6027              JZ      ?C0033
                                           ; SOURCE LINE # 1154
                                           ; SOURCE LINE # 1155
0031 900000      R     MOV     DPTR,#string
0034 120000      E     LCALL   ?C?PLDXDATA
0037 900000      R     MOV     DPTR,#bufIndex
003A E0                MOVX    A,@DPTR
003B FE                MOV     R6,A
003C A3                INC     DPTR
003D E0                MOVX    A,@DPTR
003E FF                MOV     R7,A
003F E9                MOV     A,R1
0040 2F                ADD     A,R7
0041 F9                MOV     R1,A
0042 EA                MOV     A,R2
0043 3E                ADDC    A,R6
0044 FA                MOV     R2,A
0045 120000      E     LCALL   ?C?CLDPTR
0048 FF                MOV     R7,A
0049 120000      R     LCALL   _UART_Debug_PutChar
                                           ; SOURCE LINE # 1156
004C 900000      R     MOV     DPTR,#bufIndex
004F E4                CLR     A
0050 75F001            MOV     B,#01H
0053 120000      E     LCALL   ?C?IILDX
                                           ; SOURCE LINE # 1157
0056 80BE              SJMP    ?C0031
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 36  

                                           ; SOURCE LINE # 1158
                                           ; SOURCE LINE # 1159
0058         ?C0033:
0058 22                RET     
             ; FUNCTION _UART_Debug_PutString (END)

             ; FUNCTION _UART_Debug_PutArray (BEGIN)
                                           ; SOURCE LINE # 1191
0000 900000      R     MOV     DPTR,#string
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1193
                                           ; SOURCE LINE # 1194
000B 900000      R     MOV     DPTR,#bufIndex
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1197
0010 900000      R     MOV     DPTR,#UART_Debug_initVar
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 602F              JZ      ?C0037
                                           ; SOURCE LINE # 1198
0018         ?C0035:
                                           ; SOURCE LINE # 1199
0018 900000      R     MOV     DPTR,#byteCount
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 900000      R     MOV     DPTR,#bufIndex
0020 E0                MOVX    A,@DPTR
0021 FE                MOV     R6,A
0022 EE                MOV     A,R6
0023 C3                CLR     C
0024 9F                SUBB    A,R7
0025 5020              JNC     ?C0037
                                           ; SOURCE LINE # 1200
                                           ; SOURCE LINE # 1201
0027 900000      R     MOV     DPTR,#string
002A 120000      E     LCALL   ?C?PLDXDATA
002D 900000      R     MOV     DPTR,#bufIndex
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 E9                MOV     A,R1
0033 2F                ADD     A,R7
0034 F9                MOV     R1,A
0035 E4                CLR     A
0036 3A                ADDC    A,R2
0037 FA                MOV     R2,A
0038 120000      E     LCALL   ?C?CLDPTR
003B FF                MOV     R7,A
003C 120000      R     LCALL   _UART_Debug_PutChar
                                           ; SOURCE LINE # 1202
003F 900000      R     MOV     DPTR,#bufIndex
0042 E0                MOVX    A,@DPTR
0043 04                INC     A
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1203
0045 80D1              SJMP    ?C0035
                                           ; SOURCE LINE # 1204
                                           ; SOURCE LINE # 1205
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 37  

0047         ?C0037:
0047 22                RET     
             ; FUNCTION _UART_Debug_PutArray (END)

             ; FUNCTION _UART_Debug_PutCRLF (BEGIN)
                                           ; SOURCE LINE # 1230
0000 900000      R     MOV     DPTR,#txDataByte
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1231
                                           ; SOURCE LINE # 1233
0005 900000      R     MOV     DPTR,#UART_Debug_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 6012              JZ      ?C0039
                                           ; SOURCE LINE # 1234
                                           ; SOURCE LINE # 1235
000D 900000      R     MOV     DPTR,#txDataByte
0010 E0                MOVX    A,@DPTR
0011 FF                MOV     R7,A
0012 120000      R     LCALL   _UART_Debug_PutChar
                                           ; SOURCE LINE # 1236
0015 7F0D              MOV     R7,#0DH
0017 120000      R     LCALL   _UART_Debug_PutChar
                                           ; SOURCE LINE # 1237
001A 7F0A              MOV     R7,#0AH
001C 120000      R     LCALL   _UART_Debug_PutChar
                                           ; SOURCE LINE # 1238
                                           ; SOURCE LINE # 1239
001F         ?C0039:
001F 22                RET     
             ; FUNCTION _UART_Debug_PutCRLF (END)

             ; FUNCTION UART_Debug_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 1273
                                           ; SOURCE LINE # 1275
                                           ; SOURCE LINE # 1281
0000 9044C8            MOV     DPTR,#044C8H
0003 7402              MOV     A,#02H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1283
0006 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B 900000      R     MOV     DPTR,#UART_Debug_txBufferRead
000E E0                MOVX    A,@DPTR
000F FE                MOV     R6,A
0010 EE                MOV     A,R6
0011 B50707            CJNE    A,AR7,?C0040
                                           ; SOURCE LINE # 1284
                                           ; SOURCE LINE # 1285
0014 900000      R     MOV     DPTR,#size
0017 E4                CLR     A
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1286
0019 803B              SJMP    ?C0041
001B         ?C0040:
                                           ; SOURCE LINE # 1287
001B 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 38  

0020 900000      R     MOV     DPTR,#UART_Debug_txBufferRead
0023 E0                MOVX    A,@DPTR
0024 FE                MOV     R6,A
0025 EE                MOV     A,R6
0026 C3                CLR     C
0027 9F                SUBB    A,R7
0028 5015              JNC     ?C0042
                                           ; SOURCE LINE # 1288
                                           ; SOURCE LINE # 1289
002A 900000      R     MOV     DPTR,#UART_Debug_txBufferRead
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
002F 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
0032 E0                MOVX    A,@DPTR
0033 FE                MOV     R6,A
0034 C3                CLR     C
0035 EE                MOV     A,R6
0036 9F                SUBB    A,R7
0037 FF                MOV     R7,A
0038 900000      R     MOV     DPTR,#size
003B EF                MOV     A,R7
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1290
003D 8017              SJMP    ?C0041
003F         ?C0042:
                                           ; SOURCE LINE # 1292
                                           ; SOURCE LINE # 1293
003F 900000      R     MOV     DPTR,#UART_Debug_txBufferRead
0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 C3                CLR     C
0045 7464              MOV     A,#064H
0047 9F                SUBB    A,R7
0048 FF                MOV     R7,A
0049 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
004C E0                MOVX    A,@DPTR
004D FE                MOV     R6,A
004E EF                MOV     A,R7
004F 2E                ADD     A,R6
0050 FF                MOV     R7,A
0051 900000      R     MOV     DPTR,#size
0054 EF                MOV     A,R7
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1295
0056         ?C0041:
                                           ; SOURCE LINE # 1297
0056 9044C0            MOV     DPTR,#044C0H
0059 7402              MOV     A,#02H
005B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1320
005C 900000      R     MOV     DPTR,#size
005F E0                MOVX    A,@DPTR
0060 FF                MOV     R7,A
                                           ; SOURCE LINE # 1321
0061         ?C0044:
0061 22                RET     
             ; FUNCTION UART_Debug_GetTxBufferSize (END)

             ; FUNCTION UART_Debug_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 1354
                                           ; SOURCE LINE # 1355
                                           ; SOURCE LINE # 1358
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 39  

0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1360
0008 906496            MOV     DPTR,#06496H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1361
0013 906496            MOV     DPTR,#06496H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1362
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1367
0026 9044C8            MOV     DPTR,#044C8H
0029 7402              MOV     A,#02H
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1369
002C 900000      R     MOV     DPTR,#UART_Debug_txBufferRead
002F E4                CLR     A
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1370
0031 900000      R     MOV     DPTR,#UART_Debug_txBufferWrite
0034 E4                CLR     A
0035 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1373
0036 9044C0            MOV     DPTR,#044C0H
0039 7402              MOV     A,#02H
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1376
003C 22                RET     
             ; FUNCTION UART_Debug_ClearTxBuffer (END)

             ; FUNCTION _UART_Debug_SendBreak (BEGIN)
                                           ; SOURCE LINE # 1440
0000 900000      R     MOV     DPTR,#retMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1441
                                           ; SOURCE LINE # 1444
0005 900000      R     MOV     DPTR,#UART_Debug_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7003              JNZ     $ + 5H
000D 020000      R     LJMP    ?C0059
                                           ; SOURCE LINE # 1445
                                           ; SOURCE LINE # 1490
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 40  

0010 900000      R     MOV     DPTR,#retMode
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 600A              JZ      ?C0048
0018 900000      R     MOV     DPTR,#retMode
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 6403              XRL     A,#03H
0020 7028              JNZ     ?C0047
0022         ?C0048:
                                           ; SOURCE LINE # 1492
                                           ; SOURCE LINE # 1501
0022 906435            MOV     DPTR,#06435H
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 900000      R     MOV     DPTR,#txPeriod
002A EF                MOV     A,R7
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1502
002C 906435            MOV     DPTR,#06435H
002F 7467              MOV     A,#067H
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1509
0032 906446            MOV     DPTR,#06446H
0035 E4                CLR     A
0036 F0                MOVX    @DPTR,A
0037         ?C0051:
                                           ; SOURCE LINE # 1512
                                           ; SOURCE LINE # 1513
0037 906465            MOV     DPTR,#06465H
003A E0                MOVX    A,@DPTR
003B FF                MOV     R7,A
003C 900000      R     MOV     DPTR,#tmpStat
003F EF                MOV     A,R7
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1514
                                           ; SOURCE LINE # 1515
0041 900000      R     MOV     DPTR,#tmpStat
0044 E0                MOVX    A,@DPTR
0045 FF                MOV     R7,A
0046 EF                MOV     A,R7
0047 20E1ED            JB      ACC.1,?C0051
                                           ; SOURCE LINE # 1516
004A         ?C0047:
                                           ; SOURCE LINE # 1518
004A 900000      R     MOV     DPTR,#retMode
004D E0                MOVX    A,@DPTR
004E FF                MOV     R7,A
004F EF                MOV     A,R7
0050 6401              XRL     A,#01H
0052 6009              JZ      ?C0056
0054 900000      R     MOV     DPTR,#retMode
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
0059 EF                MOV     A,R7
005A B40316            CJNE    A,#03H,?C0052
                                           ; SOURCE LINE # 1520
005D         ?C0056:
                                           ; SOURCE LINE # 1522
                                           ; SOURCE LINE # 1523
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 41  

005D 906465            MOV     DPTR,#06465H
0060 E0                MOVX    A,@DPTR
0061 FF                MOV     R7,A
0062 900000      R     MOV     DPTR,#tmpStat
0065 EF                MOV     A,R7
0066 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1524
                                           ; SOURCE LINE # 1525
0067 900000      R     MOV     DPTR,#tmpStat
006A E0                MOVX    A,@DPTR
006B FF                MOV     R7,A
006C EF                MOV     A,R7
006D F4                CPL     A
006E FF                MOV     R7,A
006F EF                MOV     A,R7
0070 20E0EA            JB      ACC.0,?C0056
                                           ; SOURCE LINE # 1526
0073         ?C0052:
                                           ; SOURCE LINE # 1528
0073 900000      R     MOV     DPTR,#retMode
0076 E0                MOVX    A,@DPTR
0077 FF                MOV     R7,A
0078 EF                MOV     A,R7
0079 6401              XRL     A,#01H
007B 6013              JZ      ?C0058
007D 900000      R     MOV     DPTR,#retMode
0080 E0                MOVX    A,@DPTR
0081 FF                MOV     R7,A
0082 EF                MOV     A,R7
0083 6402              XRL     A,#02H
0085 6009              JZ      ?C0058
0087 900000      R     MOV     DPTR,#retMode
008A E0                MOVX    A,@DPTR
008B FF                MOV     R7,A
008C EF                MOV     A,R7
008D B4030A            CJNE    A,#03H,?C0059
0090         ?C0058:
                                           ; SOURCE LINE # 1531
                                           ; SOURCE LINE # 1534
0090 900000      R     MOV     DPTR,#txPeriod
0093 E0                MOVX    A,@DPTR
0094 FF                MOV     R7,A
0095 906435            MOV     DPTR,#06435H
0098 EF                MOV     A,R7
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1544
                                           ; SOURCE LINE # 1546
                                           ; SOURCE LINE # 1547
009A         ?C0059:
009A 22                RET     
             ; FUNCTION _UART_Debug_SendBreak (END)

             ; FUNCTION _UART_Debug_SetTxAddressMode (BEGIN)
                                           ; SOURCE LINE # 1572
0000 900000      R     MOV     DPTR,#addressMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1573
                                           ; SOURCE LINE # 1575
                                           ; SOURCE LINE # 1576
                                           ; SOURCE LINE # 1581
0005         ?C0060:
C51 COMPILER V9.51   UART_DEBUG                                                            12/03/2015 21:05:11 PAGE 42  

                                           ; SOURCE LINE # 1583
                                           ; SOURCE LINE # 1588
                                           ; SOURCE LINE # 1589
0005         ?C0062:
0005 22                RET     
             ; FUNCTION _UART_Debug_SetTxAddressMode (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    994    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    104      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
